<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python的内存管理及垃圾回收机制</title>
      <link href="/2020/08/14/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/08/14/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先要记住一句话：</p><blockquote><p>“Python采用的是<strong>引用计数机制为主，标记清除和分代收集两种机制为辅</strong>的策略。”</p></blockquote><a id="more"></a><h2 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h2><p>首先来了解一下引用计数器，因为是<strong>以引用计数器为主</strong>的机制。</p><h3 id="1-环状双向链表"><a href="#1-环状双向链表" class="headerlink" title="1.环状双向链表"></a>1.环状双向链表</h3><p>在Python中，有一个环状的双向链表叫<strong>refchain</strong>，任何对象都会被放在这个环状双向链表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;cat&quot;</span><br><span class="line">age &#x3D; 10</span><br><span class="line">hobby &#x3D; [&quot;eat fish&quot;, &quot;sleep&quot;]</span><br></pre></td></tr></table></figure><p>上面的代码一执行，会创建三个对象，一个字符串对象，一个整型对象，一个列表对象，这三个对象都会被放到这个链表中。</p><p>当python代码遇到<code>name = &quot;cat&quot;</code>，内部会创建一些数据（C语言源码是创建了一个结构体）：上一个对象，下一个对象，类型，引用的个数等等，当前对象的类型是字符串，引用的个数是1，因为name这个变量名引用了当前这个对象，如果<code>new = name</code>，那么这个引用计数会加一。</p><p>如果这个对象是由多个元素组成的，还会有一个值记录它的元素个数。</p><p>C的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define PyObject_HEAD       PyObject ob_base;</span><br><span class="line">#define PyObject_VAR_HEAD      PyVarObject ob_base;</span><br><span class="line">&#x2F;&#x2F; 宏定义，包含 上一个、下一个，用于构造双向链表用。(放到refchain链表中时，要用到)</span><br><span class="line">#define _PyObject_HEAD_EXTRA            \</span><br><span class="line">    struct _object *_ob_next;           \</span><br><span class="line">    struct _object *_ob_prev;</span><br><span class="line">typedef struct _object &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA &#x2F;&#x2F; 用于构造双向链表</span><br><span class="line">    Py_ssize_t ob_refcnt;  &#x2F;&#x2F; 引用计数器</span><br><span class="line">    struct _typeobject *ob_type;    &#x2F;&#x2F; 数据类型</span><br><span class="line">&#125; PyObject;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject ob_base;   &#x2F;&#x2F; PyObject对象</span><br><span class="line">    Py_ssize_t ob_size; &#x2F;* Number of items in variable part，即：元素个数 *&#x2F;</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>如果是不同类型的数据，内部会创建以下的内容：</p><ul><li>float类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    double ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure></li><li>int类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[1];</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;* Long (arbitrary precision) integer object interface *&#x2F;</span><br><span class="line">typedef struct _longobject PyLongObject; &#x2F;* Revealed in longintrepr.h *&#x2F;</span><br></pre></td></tr></table></figure></li><li>str类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t length;          &#x2F;* Number of code points in the string *&#x2F;</span><br><span class="line">    Py_hash_t hash;             &#x2F;* Hash value; -1 if not set *&#x2F;</span><br><span class="line">    struct &#123;</span><br><span class="line">        unsigned int interned:2;</span><br><span class="line">        &#x2F;* Character size:</span><br><span class="line">       - PyUnicode_WCHAR_KIND (0):</span><br><span class="line">         * character type &#x3D; wchar_t (16 or 32 bits, depending on the</span><br><span class="line">           platform)</span><br><span class="line">       - PyUnicode_1BYTE_KIND (1):</span><br><span class="line">         * character type &#x3D; Py_UCS1 (8 bits, unsigned)</span><br><span class="line">         * all characters are in the range U+0000-U+00FF (latin1)</span><br><span class="line">         * if ascii is set, all characters are in the range U+0000-U+007F</span><br><span class="line">           (ASCII), otherwise at least one character is in the range</span><br><span class="line">           U+0080-U+00FF</span><br><span class="line">       - PyUnicode_2BYTE_KIND (2):</span><br><span class="line">         * character type &#x3D; Py_UCS2 (16 bits, unsigned)</span><br><span class="line">         * all characters are in the range U+0000-U+FFFF (BMP)</span><br><span class="line">         * at least one character is in the range U+0100-U+FFFF</span><br><span class="line">       - PyUnicode_4BYTE_KIND (4):</span><br><span class="line">         * character type &#x3D; Py_UCS4 (32 bits, unsigned)</span><br><span class="line">         * all characters are in the range U+0000-U+10FFFF</span><br><span class="line">         * at least one character is in the range U+10000-U+10FFFF</span><br><span class="line">       *&#x2F;</span><br><span class="line">        unsigned int kind:3;</span><br><span class="line">        unsigned int compact:1;</span><br><span class="line">        unsigned int ascii:1;</span><br><span class="line">        unsigned int ready:1;</span><br><span class="line">        unsigned int :24;</span><br><span class="line">    &#125; state;</span><br><span class="line">    wchar_t *wstr;              &#x2F;* wchar_t representation (null-terminated) *&#x2F;</span><br><span class="line">&#125; PyASCIIObject;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyASCIIObject _base;</span><br><span class="line">    Py_ssize_t utf8_length;     &#x2F;* Number of bytes in utf8, excluding the</span><br><span class="line">                                 * terminating \0. *&#x2F;</span><br><span class="line">    char *utf8;                 &#x2F;* UTF-8 representation (null-terminated) *&#x2F;</span><br><span class="line">    Py_ssize_t wstr_length;     &#x2F;* Number of code points in wstr, possible</span><br><span class="line">                                 * surrogates count as two code points. *&#x2F;</span><br><span class="line">&#125; PyCompactUnicodeObject;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyCompactUnicodeObject _base;</span><br><span class="line">    union &#123;</span><br><span class="line">        void *any;</span><br><span class="line">        Py_UCS1 *latin1;</span><br><span class="line">        Py_UCS2 *ucs2;</span><br><span class="line">        Py_UCS4 *ucs4;</span><br><span class="line">    &#125; data;                     &#x2F;* Canonical, smallest-form Unicode buffer *&#x2F;</span><br><span class="line">&#125; PyUnicodeObject;</span><br></pre></td></tr></table></figure></li><li>list类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure></li><li>tuple类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[1];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure></li><li>dict类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br></pre></td></tr></table></figure></li></ul><p>其中：</p><ul><li>_ob_next ： refchian中的上一个对象</li><li>_ob_prev：refchain中的下一个对象</li><li>ob_refnt：引用计数器</li><li>ob_type：是当前对象的类型</li><li>ob_fval：是这个对象的值</li></ul><p>当python运行程序时，会根据数据类型的不同找到它对应的结构体，根据结构体中的字段来进行创建相关数据，然后将这个对象添加到refchain中。</p><p>大体机制：<br>每个对象中有ob_refcnt就是引用计数器，默认值为1，当有其他变量引用对象时，引用计数器的值会增加，如果引用这个对象的变量被删除或者引用别的对象了，那么这个引用计数器的值会减小，当引用计数器的值变为0时，意味着没有变量在使用这个对象了，那么这个对象就变成了需要被删除的垃圾，系统就会将这个对象从refchian里面移除，将对象销毁，把这块内存还给系统。</p><h3 id="2-单纯使用引用计数器进行垃圾回收的问题：循环引用"><a href="#2-单纯使用引用计数器进行垃圾回收的问题：循环引用" class="headerlink" title="2.单纯使用引用计数器进行垃圾回收的问题：循环引用"></a>2.单纯使用引用计数器进行垃圾回收的问题：循环引用</h3><p>如果是这样的一个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># refchian中创建一个列表对象，因为v1&#x3D;对象，所以对象的引用计数器为1</span><br><span class="line">v1 &#x3D; [11,22,33]</span><br><span class="line"># 同理为1</span><br><span class="line">v2 &#x3D; [44,55,66]</span><br><span class="line"># 把v2追加到v1中，那么[11,22,33]的引用计数器就会加一，变为2</span><br><span class="line">v1.append(v2)</span><br><span class="line"># 同理为2</span><br><span class="line">v2.append(v1)</span><br></pre></td></tr></table></figure><p>这时候，如果删除了变量v1和变量v2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># [11,22,33] 的引用计数器减一，变为1</span><br><span class="line">del v1</span><br><span class="line"># [44,55,66]同理为1</span><br><span class="line">del v2</span><br></pre></td></tr></table></figure><p>这时候就会有一个问题，就是已经没有变量引用对象[11,22,33]和[44,55,66]了，但是因为他们的引用计数器不为0，这两个对象的内存空间没有被回收，所以他们会永远在内存中，而又永远不会被使用到。</p><p>所以为了解决这个问题，就有了标记清除。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除就是为了解决引用计数器循环引用的问题。</p><p>实习方法就是在Python的底层再去维护一个环形双向链表，这个链表用来存放可能存在循环引用问题的对象。（只有对象可以再放其他元素的对象才会出现循环引用问题，列表，字典，元组和集合）</p><p>在Python内部，在某种情况下，回去扫描这个存放可能存在循环引用问题的对象的链表，如果发现有循环引用，就把双方的引用计数器都减一，如果引用计数器减为0，回收内存。</p><p>但是标记清除也存在问题：</p><ul><li>什么时候会扫描一次</li><li>扫描一次存在耗时久的问题</li></ul><p>所以又引入了分代回收。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>实现方式就是把标记清除的那个链表分成了三个链表，这三个链表分别是：0代，1代，2代。</p><ul><li>当0代中的对象个数超过700个，扫描一次0代。</li><li>0代如果扫描10次，则1代扫描一次。</li><li>1代扫描10次，2代扫描一次。</li></ul><p>三个链表的阈值是不同的，0代是对象个数，1代和2代都是前一代的扫描次数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Python中维护了一个叫refchain的双向环状链表，这个链表用来存储程序创建的所有对象，每种类型的对象都有一个ob_refcnt引用计数器的值，当有变量引用对象时，引用计数器的值就会加一，当引用对象的变量减少了的时候，引用计数器的值就会减一，当引用计数器变为0时，就会进行垃圾回收。</p><p>但是在Python中，对于有多个元素组成的对象，可能还会有循环引用的问题，为了解决这个问题，Python又引用了标记清除和分代回收，所以在Python内部实际上要维护四个双向环状链表，分别是：</p><ul><li>refchian</li><li>0代 700个</li><li>1代 0代扫描10次</li><li>2代 1代扫描10次<br>在源码内部，当达到各自的阈值时，就会扫描链表，发现循环引用就会想相关对象的引用计数器减一，如果引用计数器的值被减为0，那么这个对象就会被销毁，这个对象占用的内存空间就会被回收。</li></ul><h2 id="优化：缓存"><a href="#优化：缓存" class="headerlink" title="优化：缓存"></a>优化：缓存</h2><p>在Python内部，源码对上述过程进行了优化，这个优化就是缓存。</p><h3 id="1-内存池"><a href="#1-内存池" class="headerlink" title="1.内存池"></a>1.内存池</h3><p>为了避免重复创建和销毁一些常见对象，就会维护一个内存池。</p><p>在启动Python解释器时，内部会自动为我们创建-5~256这些数字放到内存池中，如果有变量需要指向这些值，内存不会开辟新的内存，直接从内存池中取。</p><p>所以如果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 &#x3D; 8</span><br><span class="line">v2 &#x3D; 8</span><br></pre></td></tr></table></figure><p>打印一下v1和v2的id，会发现他们的id是相同的。</p><p>而且内存池中的对象，他们的引用计数器不会变为0，因为初始化的时候，他们的引用计数器就为1，这时候没有变量引用他们，所以当引用他们的变量引用后又不再引用他们的时候，他们的引用计数器也不会变为0。</p><h3 id="2-free-list（缓冲池）"><a href="#2-free-list（缓冲池）" class="headerlink" title="2.free_list（缓冲池）"></a>2.free_list（缓冲池）</h3><p>当一个对象的引用计数器变为0时，先不回收，而是把这个对象放到free_list中，当作缓存，这样再创建对象时，就不开辟新的内存，直接使用free_list中的对象的内存，把这块内存初始化，再把这个对象放到refchain中。</p><p>当然这个缓冲池也是有大小限制的，如果一个对象的引用计数器变为0，而此时缓冲池也已经满了，那么这个对象还是会被直接销毁的。</p><p>float，list，tuple，dict采用这种机制。</p><ul><li>float类型，维护的free_list链表最多可缓存100个float对象。</li><li>list类型，维护的free_list链表最多可缓存80个list对象。</li><li>dict类型，维护的free_list链表最多可缓存80个dict对象。</li></ul><p>tuple类型的比较特殊，可以理解为如果是tuple类型的，free_list的容量为20，这时候的free_list有20个index，index从0到19，每个索引位置都存放了一个链表，index为0的位置，存放的是空元组，index为1的位置存放的是元组长度为1的元组，这样以此类推。每一个链表都可以存放2000个元组。</p><p>字符串类型的有两种优化方式：<br>1.字符池<br>2.字符串驻留机制</p><ul><li>字符池就是和int的内存池类似，python内部会将ASCII的所有字符存在一个叫<code>unicode_latin[256]</code>的链表中。</li><li>字符串驻留机制：python会将只有字母、数字、下划线并且长度不大于20的字符串进行驻留，放到内存，如果下次再创建一个一模一样的值，就不再开辟新的内存空间。</li></ul><p>详见：<a href="https://pythonav.com/wiki/detail/6/88/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/6/88/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的*args和**kwargs</title>
      <link href="/2020/08/13/Python%E7%9A%84args%E5%92%8Ckwargs/"/>
      <url>/2020/08/13/Python%E7%9A%84args%E5%92%8Ckwargs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当定义一个函数，这个函数可能会有不定长参数的时候，就会在函数的接收参数的括号的最后加上<code>*args, **kwargs</code>。</p><ul><li>*agrs用来接收非关键字参数，以元组的形式保存，这个形参的名字叫<code>args</code>(非关键字参数就是直接传递进来的，没有名字的参数，与关键字参数相对)。</li><li>**kwargs用来接收关键字参数，以字典的形式保存，这个形参的名字叫<code>kwargs</code>(关键字参数就是有名字的参数，比如传递进来的<code>age=12</code>)。<a id="more"></a>也可以把args和kwargs起成别的名字。</li></ul><p>当前程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test(a, b, *args, **kwargs):</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line"></span><br><span class="line">test(11, 22)</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test09.py</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>这时候a，b接收了11和22，而args和kwargs没有接收参数，所以为空元组和空字典。</p><p>如果再传递几个非关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(11, 22, 33, 44, 55, 66)</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [4]: test(11, 22, 33, 44, 55, 66)</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">(33, 44, 55, 66)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>这时候多余的非关键字参数都被传递到了args里，作为一个元组保存起来。</p><p>再传递几个关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [6]: test(11, 22, 33, 44, 55, 66, name&#x3D;&quot;happy&quot;, age&#x3D;100)</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">(33, 44, 55, 66)</span><br><span class="line">&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;</span><br></pre></td></tr></table></figure><p>如果定义两个函数test01和test02，给test01传递一些参数，test01再把这些参数传递给test02：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def test01(a, b, *args, **kwargs):</span><br><span class="line">print(&quot;test01&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line"></span><br><span class="line">test02(a, b, args, kwargs)</span><br><span class="line"></span><br><span class="line">def test02(a, b, *args, **kwargs):</span><br><span class="line">print(&quot;test02&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test01(11, 22, 33, 44, 55, 66, name&#x3D;&quot;happy&quot;, age&#x3D;100)</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test09.py</span><br><span class="line">test01</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">(33, 44, 55, 66)</span><br><span class="line">&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;</span><br><span class="line">test02</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">((33, 44, 55, 66), &#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>这时候，传给test01的除了a和b的所有参数都被test02当作一个元组存起来了。这是因为，传递给test01的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 11</span><br><span class="line">b &#x3D; 22</span><br><span class="line">args &#x3D; (33, 44, 55, 66)</span><br><span class="line">kwargs &#x3D; &#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;</span><br></pre></td></tr></table></figure><p>这时候再传递给test02，test02把11给了a，把22给了b，后面两个参数是一个元组一个字典，都是非关键字参数，所以就一起给了args。</p><p>所以如果想把传递给test01的参数原封不动的传给test02，就需要把元组和字典拆包，实现方法是在args前面加一个“<em>”，在kwargs前加一个“*</em>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def test01(a, b, *args, **kwargs):</span><br><span class="line">print(&quot;test01&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line"></span><br><span class="line">test02(a, b, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">def test02(a, b, *args, **kwargs):</span><br><span class="line">print(&quot;test02&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test01(11, 22, 33, 44, 55, 66, name&#x3D;&quot;happy&quot;, age&#x3D;100)</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test09.py</span><br><span class="line">test01</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">(33, 44, 55, 66)</span><br><span class="line">&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;</span><br><span class="line">test02</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">(33, 44, 55, 66)</span><br><span class="line">&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;</span><br></pre></td></tr></table></figure><p>所以<code>def test01(a, b, *args, **kwargs):</code>表示可以接收不定长的参数，以元组或字典保存。</p><p>而<code>test02(a, b, *args, **kwargs)</code>表示的是拆包，把元组拆成单个元素，把字典拆成<code>变量名=某个值</code>的形式。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Python多任务（线程，进程，协程）</title>
      <link href="/2020/08/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E5%A4%9A%E4%BB%BB%E5%8A%A1%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%EF%BC%89/"/>
      <url>/2020/08/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E5%A4%9A%E4%BB%BB%E5%8A%A1%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>看一下下面的程序：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;sing....&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;dancing...&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    sing()</span><br><span class="line">    dance()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行这个程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br></pre></td></tr></table></figure><p>一共花费了十秒。</p><p>修改程序为多任务的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;sing....&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;dancing...&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sing)</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;dance)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python test02.py</span><br><span class="line">sing....</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">sing....</span><br><span class="line">dancing...</span><br><span class="line">sing....</span><br><span class="line">dancing...</span><br><span class="line">sing....</span><br><span class="line">dancing...</span><br><span class="line">sing....</span><br></pre></td></tr></table></figure><p>所谓的多任务，就是同时可以做多件事情。</p><p>一台计算机同时可以做多少件事情，是由CPU觉得的，如果CPU的双核的，说明同时可以做两件事情，如果是四核的，就可以同时做四件事情。</p><p>如果计算机是单核的，怎么实现多任务？</p><p>一个比较好理解的办法是，时间片轮转，比如当前有四个程序，CPU是一核的，那么就让第一个程序先执行0.00001s，然后让下一个程序再执行0.00001s，这样每个程序都执行了0.00001s之后，再来执行第一个程序。因为人是察觉不到0.0001s的切换的，所以在我们看来，程序就像在“一起”执行一样，这样的多任务，叫并发，并发是加到多任务。</p><p>如果计算机是双核的，现在有两个程序，那么这两个程序可以同时执行，这样真的一起同时在执行叫做“并行”，并行是真的多任务。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>那么怎样才能让Python程序完成多任务呢。</p><p>线程就是实现多任务的一种手段。</p><h4 id="1-threading模块"><a href="#1-threading模块" class="headerlink" title="1.threading模块"></a>1.threading模块</h4><p>在Python中有一个模块是threading，这个模块中有一个类是Thread，用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;123456&quot;)</span><br><span class="line"></span><br><span class="line"># target接收的是函数名，不是函数的调用</span><br><span class="line">t1 &#x3D; threading.Thread(target &#x3D; test)</span><br><span class="line">t1.start()</span><br></pre></td></tr></table></figure><p>类名+“（）”就创建了一个对象，这个对象就是之后要启动的线程。</p><p>当t1.start()的时候，这个线程就真正开始创建并被执行。</p><p>还是这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;sing....&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;dancing...&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sing)</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;dance)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>主线程从上往下执行，当走到def sing的时候，不进入函数执行，因为这是一个函数的定义，继续往下走，到dance的时候也不执行，走到main也不执行，遇到<code>if __name__ == &quot;__main__&quot;:</code>执行调用里面的main()，然后进入main这个函数。</p><p><code>t1 = threading.Thread(target=sing)</code>的时候，创建了一个对象，把它赋给了t1，遇到<code>t2 = threading.Thread(target=dance)</code>的时候，创建了一个对象，把它赋给了t2。</p><p>当主线程运行到<code>t1.start()</code>的时候，主线程创建了一个子线程，这个子线程去执行sing函数，主线程继续往下执行，当遇到<code>t2.start()</code>的时候，主线程创建另外一个子线程，这个子线程去执行dance函数。</p><p>主线程往下就没有执行的代码了，这时候主线程会等待子线程执行结束，然后主线程再结束。</p><h4 id="2-查看线程的数量"><a href="#2-查看线程的数量" class="headerlink" title="2.查看线程的数量"></a>2.查看线程的数量</h4><p>threading模块中有一个有一个方法是enumerate，只要调用threading.enumerate()他的返回值就是一个列表，这个列表中的元素就是主线程和子线程。</p><p>修改程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;sing....&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;dancing...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sing)</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;dance)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">dancing...</span><br><span class="line">[&lt;_MainThread(MainThread, started 9080)&gt;]</span><br></pre></td></tr></table></figure><p>发现打印出来的线程里面只有一个是主线程，没有其他两个子线程。</p><p>原因是当主线程走到t1.start()的时候创建了一个子线程，在t2.start()的时候又创建了一个子线程，然后主线程继续往下走，走到print，这时候这个程序有三个线程，又因为这三个线程都是没有延迟的，所以先让哪个线程执行就取决于操作系统，操作系统在调度这三个线程的时候，让谁先执行是不确定的。所以线程的执行是没有先后顺序的。</p><p>如果想让某个线程先执行可以采用一个方法就是让其他的线程延时。</p><p>想要看到系统什么时刻有哪几个线程在运行，方法如下：</p><p>修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;sing....第%d秒--&quot; % i)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(&quot;dancing...第%d秒--&quot; % i)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sing)</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;dance)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    if len(threading.enumerate()) &lt;&#x3D; 1:</span><br><span class="line">    break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>循环打印当前系统中的线程，如果当前系统中只剩下一个线程，就是主线程，那么就退出循环。</p><p>执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">sing....▒▒0▒▒--</span><br><span class="line">dancing...▒▒0▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒1▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">sing....▒▒1▒▒--</span><br><span class="line">sing....▒▒2▒▒--</span><br><span class="line">dancing...▒▒2▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒3▒▒--</span><br><span class="line">sing....▒▒3▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒4▒▒--</span><br><span class="line">sing....▒▒4▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒5▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒6▒▒--</span><br><span class="line">dancing...▒▒7▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒8▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br><span class="line">dancing...▒▒9▒▒--</span><br><span class="line">[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]</span><br></pre></td></tr></table></figure><p>可以看到每一秒钟程序的线程，前五秒是三个线程，到了第五秒，程序里面有两个线程，因为循环5次，每次休眠1秒的sing线程结束了，然后到了第十秒，第二个子线程也执行完了，程序中就只剩一个主线程，所以退出循环不打印了。这时候主线程也结束，程序结束。</p><p>所以如果创建Thread来执行函数，当这个函数执行完，这个子线程也就结束了。</p><p>主线程结束，程序就结束了。所以主线程会等待所有的子线程执行结束再结束。</p><h4 id="3-子线程是什么时候被创建的，什么时候被执行的"><a href="#3-子线程是什么时候被创建的，什么时候被执行的" class="headerlink" title="3.子线程是什么时候被创建的，什么时候被执行的"></a>3.子线程是什么时候被创建的，什么时候被执行的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import threading</span><br><span class="line"></span><br><span class="line">In [2]: def test():</span><br><span class="line">   ...:     print(&quot;------1--------&quot;)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [3]: t1 &#x3D; threading.Thread(target&#x3D;test)</span><br><span class="line"></span><br><span class="line">In [4]: t1.start()</span><br><span class="line">------1--------</span><br></pre></td></tr></table></figure><p>当t1被赋值的时候，test函数并没有被调用没有被执行，而是start的时候test函数才被执行，所以说明线程是在被调用的时候才执行。</p><p>那线程是什么时候被创建的?</p><p>是<code>t1 = threading.Thread(target=test)</code>的时候被创建的，还是<code>t1.start()</code>的时候被创建的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;sing....&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">print(threading.enumerate())</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sing)</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line">    t1.start()</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在<code>t1 = threading.Thread(target=sing)</code>之前查看当前程序有多少线程，在<code>t1 = threading.Thread(target=sing)</code>之后查看当前程序有多少线程，在start之后再查看一次。</p><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">[&lt;_MainThread(MainThread, started 11772)&gt;]</span><br><span class="line">[&lt;_MainThread(MainThread, started 11772)&gt;]</span><br><span class="line">sing....</span><br><span class="line">[&lt;_MainThread(MainThread, started 11772)&gt;, &lt;Thread(Thread-1, started 11456)&gt;]</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br><span class="line">sing....</span><br></pre></td></tr></table></figure><p>在start前打印的两次线程中，都没有线程Thread-1，说明当t1.start()的时候，线程才真正被创建和执行。</p><p>所以当调用Thread的时候，不会创建线程，当调用Thread创建出来的实例对象的start方法的时候线程才会被创建，以及开始运行线程。</p><p><strong>总结：</strong></p><ul><li>如果想完成多任务，就可以通过Thread创建一个<strong>对象</strong>，这个对象一调用start，子线程就会被创建和执行，这个对象执行什么就看传递的target是哪个函数名。当这个被执行的函数结束了，这个子线程就结束了。</li><li>线程真正创建是start，真正结束是函数结束。</li><li>多个线程被创建之后，执行顺序是不确定的，执行顺序取决于操作系统，如果想指定执行的先后顺序，可以通过延时来实现。</li><li>主线程最后结束，因为主线程结束程序就结束了。</li></ul><p>创建Thread对象这个过程可以理解为线程的准备工作。</p><h4 id="4-target也可以是一个类"><a href="#4-target也可以是一个类" class="headerlink" title="4.target也可以是一个类"></a>4.target也可以是一个类</h4><p>当target是一个类的时候，写法就有变化了。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">def run(self):</span><br><span class="line">for i in range(5):</span><br><span class="line">print(i)</span><br><span class="line">time.sleep(i)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t &#x3D; MyThread()</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>用类来创建线程的时候，直接把类实例化一个对象传给t就可以，调用的时候还是t.start()就可以。</p><p>这个类必须要继承<code>threading.Thread</code>，这个类里必须定义run方法，线程start之后，会自动调用run方法，执行run里面的代码。</p><p>类中没有定义start方法，这个start方法是继承自Thread的方法。</p><p>所以创建线程有两种方式：</p><ol><li><code>t1 = threading.Thread(target=函数名)</code></li></ol><ul><li>函数里面的代码是什么，线程就去执行什么</li></ul><ol start="2"><li>用类<br>定义一个类，这个类必须继承<code>threading.Thread</code>，而且这个类必须实现run方法，这个run方法中写了什么，线程就去执行什么。</li></ol><p>这种方式适合一个线程做的事情比较复杂，而且涉及多个函数，一般就把这些函数封装成一个类。</p><p>相比较而言，函数的方式更加简单。</p><p>如果类中还有其他函数想要在线程执行的适合执行，那么这个函数的调用可以写在run函数中。</p><h4 id="5-多个线程之间共享全局变量"><a href="#5-多个线程之间共享全局变量" class="headerlink" title="5.多个线程之间共享全局变量"></a>5.多个线程之间共享全局变量</h4><p>修改全局变量前提：</p><blockquote><p>在一个函数中，对全局变量进行修改的时候，到底是否需要使用global取决于是否对变量的指向进行了修改。</p><ul><li>如果进行了修改，即让全局变量指向了一个新的地方，那么必须使用global</li><li>如果仅仅是修改了全局变量指向空间的数据，就不必须使用global<br>能不能修改还看全局变量是否可变，数字、字符串、元组不可变</li></ul></blockquote><p>例如，如果全局变量是数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [9]: num &#x3D; 100</span><br><span class="line"></span><br><span class="line">In [10]: def test():</span><br><span class="line">    ...:     global num</span><br><span class="line">    ...:     num +&#x3D; 100</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [11]: print(num)</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">In [12]: test()</span><br><span class="line"></span><br><span class="line">In [13]: print(num)</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p>此时修改全局变量就要加global。</p><p>如果不加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [16]: num &#x3D; 100</span><br><span class="line"></span><br><span class="line">In [17]: def test():</span><br><span class="line">    ...:     num +&#x3D; 100</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [18]: print(num)</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">In [19]: test()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-19-fbd55f77ab7c&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 test()</span><br><span class="line"></span><br><span class="line">&lt;ipython-input-17-fabd8b626a8d&gt; in test()</span><br><span class="line">      1 def test():</span><br><span class="line">----&gt; 2     num +&#x3D; 100</span><br><span class="line">      3</span><br><span class="line"></span><br><span class="line">UnboundLocalError: local variable &#39;num&#39; referenced before assignment</span><br><span class="line"></span><br><span class="line">In [20]: print(num)</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>如果全局变量是可变对象，不修改它的指向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [22]: nums &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">In [23]: def test():</span><br><span class="line">    ...:     nums.append(33)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [24]: print(nums)</span><br><span class="line">[11, 22]</span><br><span class="line"></span><br><span class="line">In [25]: test()</span><br><span class="line"></span><br><span class="line">In [26]: print(nums)</span><br><span class="line">[11, 22, 33]</span><br></pre></td></tr></table></figure><p>如果全局变量是可变对象，修改它的指向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [28]: nums &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">In [29]: def test():</span><br><span class="line">    ...:     nums +&#x3D; [33]</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [30]: print(nums)</span><br><span class="line">[11, 22]</span><br><span class="line"></span><br><span class="line">In [31]: test()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-31-fbd55f77ab7c&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 test()</span><br><span class="line"></span><br><span class="line">&lt;ipython-input-29-8d9294d083c5&gt; in test()</span><br><span class="line">      1 def test():</span><br><span class="line">----&gt; 2     nums +&#x3D; [33]</span><br><span class="line">      3</span><br><span class="line"></span><br><span class="line">UnboundLocalError: local variable &#39;nums&#39; referenced before assignment</span><br><span class="line"></span><br><span class="line">In [32]: print(nums)</span><br><span class="line">[11, 22]</span><br></pre></td></tr></table></figure><p><strong>验证线程之间是共享全局变量的方法：</strong></p><p>1.创建两个线程，一个用来修改全局变量，一个在修改完全局变量后打印这个全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 全局变量</span><br><span class="line">num &#x3D; 100</span><br><span class="line"></span><br><span class="line">def test01():</span><br><span class="line">global num</span><br><span class="line">num +&#x3D; 100</span><br><span class="line">print(&quot;test01:   num &#x3D; %d&quot; % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test02():</span><br><span class="line">print(&quot;test02:   num &#x3D; %d&quot; % num)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;test01)</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;test02)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">time.sleep(1)</span><br><span class="line">t2.start()</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line">print(&quot;main thread:     num &#x3D; %d&quot; % num)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   num &#x3D; 200</span><br><span class="line">test02:   num &#x3D; 200</span><br><span class="line">main thread:     num &#x3D; 200</span><br></pre></td></tr></table></figure><p>说明线程之间是共享全局变量的。</p><p><strong>2.把全局变量当作参数传给函数</strong></p><p>修改程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test01(tmp1):</span><br><span class="line">tmp1.append(33)</span><br><span class="line">print(&quot;test01:   tmp &#x3D; %s&quot; % str(tmp1))</span><br><span class="line"></span><br><span class="line">def test02(tmp2):</span><br><span class="line">print(&quot;test02:   tmp &#x3D; %s&quot; % str(tmp2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(nums,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(nums,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">time.sleep(1)</span><br><span class="line">t2.start()</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line">print(&quot;main thread:     nums &#x3D; %s&quot; % str(nums))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>args是要传递给函数的数据，这个数据必须是个<strong>元组</strong>，就是需要写<strong>括号</strong>，可以传递多个参数，<strong>参数最后多加一个逗号“,”，不然会报错</strong>。</p></blockquote><p>运行这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   tmp &#x3D; [11, 22, 33]</span><br><span class="line">test02:   tmp &#x3D; [11, 22, 33]</span><br><span class="line">main thread:     nums &#x3D; [11, 22, 33]</span><br></pre></td></tr></table></figure><h4 id="6-共享全局变量可能遇到的问题：资源竞争"><a href="#6-共享全局变量可能遇到的问题：资源竞争" class="headerlink" title="6.共享全局变量可能遇到的问题：资源竞争"></a>6.共享全局变量可能遇到的问题：资源竞争</h4><p><strong>可能遇到资源竞争的问题。</strong></p><p>定义两个函数，他们都用来把全局变量加1，循环100次，这样如果这两个函数都执行完，如果全局变量一开始是0，那么执行完两个函数就应该是200。</p><p>程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 全局变量</span><br><span class="line">global_num &#x3D; 0</span><br><span class="line"></span><br><span class="line">def test01(num):</span><br><span class="line">global global_num</span><br><span class="line">for i in range(num):</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">print(&quot;test01:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test02(num):</span><br><span class="line">global global_num</span><br><span class="line">for i in range(num):</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">print(&quot;test02:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(100,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(100,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br><span class="line">print(&quot;main thread:     num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   num &#x3D; 100</span><br><span class="line">test02:   num &#x3D; 200</span><br><span class="line">main thread:     num &#x3D; 200</span><br></pre></td></tr></table></figure><p>这时候执行结果是正确的。</p><p>如果不是循环100次，而是循环1000000次，那么结果应该是2000000。</p><p>修改程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 全局变量</span><br><span class="line">global_num &#x3D; 0</span><br><span class="line"></span><br><span class="line">def test01(num):</span><br><span class="line">global global_num</span><br><span class="line">for i in range(num):</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">print(&quot;test01:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test02(num):</span><br><span class="line">global global_num</span><br><span class="line">for i in range(num):</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">print(&quot;test02:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(1000000,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(1000000,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br><span class="line">print(&quot;main thread:     num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   num &#x3D; 1132201</span><br><span class="line">test02:   num &#x3D; 1402099</span><br><span class="line">main thread:     num &#x3D; 1402099</span><br></pre></td></tr></table></figure><p>这时候执行结果就出错了。</p><p>因为global_num += 1这个语句在执行的时候，会分成几步，1.先取到global_num的值。2.把这个值加一。3.把这个值存起来。</p><p>操作系统如果使用了时间片轮转法，在global_num等于0的时候，线程1取到了0这个值，然后把它加一，变成了1，这时候操作系统去执行线程2，取到的值还是0，把它加一，然后存储起来，这时候global的值为1，操作系统再去执行线程1，线程1把它计算的1保存，这时候global的值依旧为1，所以虽然global的值被计算了两次，但是实际得到的结果是错误的。</p><p>所以如果多线程共享全局变量，而且同一时刻都在操作全局变量，就可能出现问题，这就是资源竞争。</p><h4 id="7-解决资源竞争问题"><a href="#7-解决资源竞争问题" class="headerlink" title="7.解决资源竞争问题"></a>7.解决资源竞争问题</h4><p>可以通过线程同步来解决问题。</p><blockquote><p>同步就是协同步调，协同就是一个先执行，再执行另一个，互相配合着执行。</p></blockquote><p>同步可以用互斥锁来实现。</p><blockquote><p>互斥锁就是当线程1要修改全局变量之前，先把这个全局变量上锁，这样其他的线程就无法修改这个数据，当前线程1用完这个全局变量后，再把锁解开。</p></blockquote><p>互斥锁的创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建所</span><br><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line"># 锁定</span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"># 释放</span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>如果一个数据是没有上锁的，那么acquire不会堵塞。</p><p>如果这个数据已经被其他线程锁定了，那么此时再上锁（acquire），会堵塞，当其他线程解锁之后，当前的线程才能上锁。</p><p><strong>互斥锁解决资源竞争问题：</strong></p><p>创建一个全局变量是锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 全局变量</span><br><span class="line">global_num &#x3D; 0</span><br><span class="line"></span><br><span class="line">def test01(num):</span><br><span class="line">global global_num</span><br><span class="line"># 上锁</span><br><span class="line">mutex.acquire()</span><br><span class="line">for i in range(num):</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">mutex.release()</span><br><span class="line">print(&quot;test01:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test02(num):</span><br><span class="line">global global_num</span><br><span class="line">mutex.acquire()</span><br><span class="line">for i in range(num):</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">mutex.release()</span><br><span class="line">print(&quot;test02:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建一个互斥锁，默认没有上锁</span><br><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(1000000,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(1000000,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br><span class="line">print(&quot;main thread:     num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   num &#x3D; 1000000</span><br><span class="line">test02:   num &#x3D; 2000000</span><br><span class="line">main thread:     num &#x3D; 2000000</span><br></pre></td></tr></table></figure><p>这时候结果是正确的，线程1和线程2不一定哪个线程会先抢到这把锁，如果一个线程给全局变量上锁了，另一个线程只能等待这个线程解锁，才能上锁，对全局变量进行操作。</p><p>上锁有一个原则是锁定的代码越少越好，所以修改程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 全局变量</span><br><span class="line">global_num &#x3D; 0</span><br><span class="line"></span><br><span class="line">def test01(num):</span><br><span class="line">global global_num</span><br><span class="line">for i in range(num):</span><br><span class="line">mutex.acquire()</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">mutex.release()</span><br><span class="line">print(&quot;test01:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test02(num):</span><br><span class="line">global global_num</span><br><span class="line">for i in range(num):</span><br><span class="line">mutex.acquire()</span><br><span class="line">global_num +&#x3D; 1</span><br><span class="line">mutex.release()</span><br><span class="line">print(&quot;test02:   num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建一个互斥锁，默认没有上锁</span><br><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(1000000,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(1000000,))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br><span class="line">print(&quot;main thread:     num &#x3D; %d&quot; % global_num)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行程序：</p><p>执行第一遍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   num &#x3D; 1921277</span><br><span class="line">test02:   num &#x3D; 2000000</span><br><span class="line">main thread:     num &#x3D; 2000000</span><br></pre></td></tr></table></figure><p>执行第二遍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test01.py</span><br><span class="line">test01:   num &#x3D; 1884133</span><br><span class="line">test02:   num &#x3D; 2000000</span><br><span class="line">main thread:     num &#x3D; 2000000</span><br></pre></td></tr></table></figure><p>这是因为，因为加锁只加了global_num += 1这一行代码，所以有可能出现在线程1执行完之前，线程1给global_num 加了一些值，线程2也给global加了一些值，所以到线程1执行完之前，global被加了超过1000000次，所以有了这样的结果。</p><h4 id="8-互斥锁带来的死锁问题"><a href="#8-互斥锁带来的死锁问题" class="headerlink" title="8.互斥锁带来的死锁问题"></a>8.互斥锁带来的死锁问题</h4><p>如果有两个资源，资源A和资源B，有两个线程，线程1和线程2。</p><p>线程1要先使用资源A，然后使用资源B，线程2要先使用资源B，再使用资源A。</p><p>如果线程1先给A上了锁，然后使用了A，进行一些操作，与此同时，线程2给B上了锁，进行了一些操作。</p><p>这时候线程1要使用资源B，发现资源B被上锁了，那线程1就等待线程2解锁。</p><p>线程2要使用资源A，发现资源A被上锁了，那线程2就等待线程1解锁。</p><p>两个线程就一直等待互相释放资源，这种现象就是死锁。</p><p><strong>如何解决死锁问题</strong>：</p><p>1.银行家算法：设计程序时尽量避免死锁</p><p>2.添加超时时间</p><p><strong>银行家算法：</strong></p><p>如果一个银行家有10块钱，有三个客户要贷款，客户A要贷款9块钱，客户B要贷款3块钱，客户C要贷款8块钱。</p><p>那么这个时候，银行家手里的钱不足以让三个客户都拿到贷款。</p><p>这个时候，先借给客户A 2块钱，借给客户B 2块钱，借给客户C 4块钱，这时候银行家手里还有2块钱。</p><table><thead><tr><th>银行家</th><th>客户A(9)</th><th>客户B(3)</th><th>客户C(8)</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>2</td><td>2</td><td>4</td></tr><tr><td>这时候银行家手里的2块钱借给客户B 1块钱，告诉其他的客户剩下的前过几天再借给他。</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>银行家</th><th>客户A(9)</th><th>客户B(3)</th><th>客户C(8)</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>2</td><td>2</td><td>4</td></tr><tr><td>1</td><td>2</td><td>3（满足）</td><td>4</td></tr><tr><td>和客户B约定好还钱的时间，当客户B归还了3块钱的时候，银行家手里就有了4块钱，把这4块钱再借给客户C。</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>银行家</th><th>客户A(9)</th><th>客户B(3)</th><th>客户C(8)</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>2</td><td>2</td><td>4</td></tr><tr><td>1</td><td>2</td><td>3（满足）</td><td>4</td></tr><tr><td>4</td><td>2</td><td>（已归还）</td><td>4</td></tr><tr><td>0</td><td>2</td><td>（已归还）</td><td>8</td></tr><tr><td>这之后客户C用完了钱，归还后再借给A 7块钱。</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>银行家</th><th>客户A(9)</th><th>客户B(3)</th><th>客户C(8)</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>2</td><td>2</td><td>4</td></tr><tr><td>1</td><td>2</td><td>3（满足）</td><td>4</td></tr><tr><td>4</td><td>2</td><td>（已归还）</td><td>4</td></tr><tr><td>0</td><td>2</td><td>（已归还）</td><td>8</td></tr><tr><td>8</td><td>2</td><td>（已归还）</td><td>（已归还）</td></tr><tr><td>1</td><td>9</td><td>（已归还）</td><td>（已归还）</td></tr><tr><td>最后客户A归还了钱，银行家收获了利息。</td><td></td><td></td><td></td></tr></tbody></table><p>所以，每个客户必须一开始就声明他们所要借款或贷款的总额，然后银行家根据资源的情况和客户的情况先算好什么时候借给谁，什么时候谁归还。</p><p>这个想法应用到操作系统，操作系统就是这个银行家，它必须提前计算好每个线程何时上锁，何时解锁，这样就在程序执行之前避免了死锁。</p><p><strong>添加超时时间</strong><br>就是为死锁设定一个超时时间，如果两个线程产生了死锁，到达这个超时时间之后，采用kill线程的方式解开死锁。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>实现多任务的另一种方式。</p><p>程序是静态的，是一个exe文件或者是其他的东西，运行起来就是进程，一个进程包含多个线程。</p><p>一个程序一般来说可以开多个，比如QQ程序，打开之后就是多个QQ进程。</p><p>进程是启动的程序，所以进程比程序多拥有了资源，比如QQ进程可以使用内存资源，可以通过网卡连接网络，以及鼠标键盘等资源。所以进程是一个资源分配的单位。</p><h4 id="1-使用进程实现多任务"><a href="#1-使用进程实现多任务" class="headerlink" title="1.使用进程实现多任务"></a>1.使用进程实现多任务</h4><p>程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; multiprocessing.Process(target&#x3D;test1)</span><br><span class="line">t2 &#x3D; multiprocessing.Process(target&#x3D;test2)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test02.py</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>此时如果是Windows系统可以在另外一个终端输入<code>tasklist</code>命令来查看当前系统运行的所有进程。</p><p>一部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">映像名称                       PID 会话名              会话&#39;#       内存使用</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">chrome.exe                   11504 Console                    1     51,440 K</span><br><span class="line">chrome.exe                   10496 Console                    1     21,892 K</span><br><span class="line">python.exe                    7680 Console                    1     11,908 K</span><br><span class="line">python.exe                    5356 Console                    1     12,032 K</span><br><span class="line">python.exe                    8984 Console                    1     12,036 K</span><br><span class="line">tasklist.exe                  6004 Console                    1      9,028 K</span><br></pre></td></tr></table></figure><p>当结束程序，再次查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映像名称                       PID 会话名              会话&#39;#       内存使用</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">conhost.exe                  11024 Console                    1     16,896 K</span><br><span class="line">chrome.exe                   11224 Console                    1     91,268 K</span><br><span class="line">chrome.exe                   12280 Console                    1     71,120 K</span><br><span class="line">chrome.exe                    1608 Console                    1     66,956 K</span><br><span class="line">chrome.exe                   11504 Console                    1     51,436 K</span><br><span class="line">chrome.exe                   10496 Console                    1     21,896 K</span><br><span class="line">tasklist.exe                  7740 Console                    1      9,016 K</span><br></pre></td></tr></table></figure><p>发现python的程序已经没有了。</p><p>如果是linux系统可以用<code>ps -aux</code>来查看。</p><p>Windows系统用<code>taskkill /pid 端口 /F</code>来停止进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;taskkill &#x2F;pid 1996 &#x2F;F</span><br><span class="line">成功: 已终止 PID 为 1996 的进程。</span><br></pre></td></tr></table></figure><p>linux系统可以用<code>kill + 进程ID</code>来停止进程。</p><p>当主进程从上到下扫描代码，开始执行时，执行到t1.start()这一行，会创建一个新的子进程，这个新的子进程拥有另一份属于自己的资源，新的子进程被创建的时候，要修改的东西会拷贝一份自己的，不修改的就不拷贝了，共享代码（因为在运行过程中不会修改代码），也就是说能共享的就会共享，不能共享的就复制一份自己的（所以有一个概念是“写时拷贝”，即修改的时候拷贝）。所以多进程会占用较大的资源，所以进程数不是越多越好。</p><p>所以在执行刚刚的程序时，可以看到三个Python进程，一个是主进程，另外两个是子进程。</p><h4 id="2-进程和线程的对比"><a href="#2-进程和线程的对比" class="headerlink" title="2.进程和线程的对比"></a>2.进程和线程的对比</h4><p>进程：是资源的总称，包括代码，包括内存等。</p><p>线程：比较轻量级，线程之间资源共享。</p><ul><li>进程仅仅是一个资源分配的单位，是一个资源总和，而线程是操作系统调度的单位。</li><li>多线程是在同一份资源的前提下执行代码，而多进程是多份资源，同一份代码或多份代码，各自使用各自的资源去执行。</li><li>每一个进程都至少拥有一个线程（主线程），真正去执行的是线程。也就是说每创建一个进程，这个进程就会有一个主线程去使用资源执行代码。</li><li>进程依赖与进程，比如一个网易云音乐运行之后是一个进程，这个进程可以开启多个线程，比如下载歌曲线程和播放歌曲线程，这两个线程之间共享资源，下载后的歌曲可以由播放线程来播放，但是一旦关闭网易云，就是关闭了进程，线程也就不存在了。</li><li>进程之间是互相独立的，比如QQ音乐和网易云音乐之间是独立的。</li></ul><h4 id="3-使用队列完成进程间通信"><a href="#3-使用队列完成进程间通信" class="headerlink" title="3.使用队列完成进程间通信"></a>3.使用队列完成进程间通信</h4><p>如果想使用多进程来实现多任务，比如想用一个进程来下载音乐，一个进程来播放下载好的音乐，那进程之间就需要进行通信。</p><p>进程间通信的一种方式是队列：Queue。</p><p><strong>Queue如何使用：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 使用Queue要导入这个模块</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line"># 创建队列，括号中可以填一个数字，表示创建的队列中可以放多少元素，队列中的元素可以放不同数据类型的数据</span><br><span class="line">q &#x3D; multiprocessing.Queue()</span><br><span class="line">q &#x3D; multiprocessing.Queue(3)</span><br><span class="line"></span><br><span class="line"># 往队列中存放数据</span><br><span class="line">q.put()</span><br><span class="line"></span><br><span class="line"># 从队列中取数据，如果这时候队列为空，q.get()就会一直等待，等到队列中有数据了再取出来。</span><br><span class="line">q.get()</span><br><span class="line"></span><br><span class="line"># 如果不想等待可以使用get_nowait，但是如果这时候队列中没有数据，就会抛异常。</span><br><span class="line">q.get_nowait()</span><br><span class="line"></span><br><span class="line"># 判断队列是否为空，如果为空，返回True，否则返回False</span><br><span class="line">q.empty()</span><br><span class="line"></span><br><span class="line"># 判断队列是否已满，已满则返回True，否则返回False</span><br><span class="line">q.full()</span><br></pre></td></tr></table></figure><p><strong>进程之间通过Queue通信的实现：</strong><br>一个进程用来下载数据，这个进程把下载好的数据存放在队列中，另一个进程从这个队列取数据来进行操作。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def download(q):</span><br><span class="line">data &#x3D; [11, 22, 33, 44]</span><br><span class="line">for tmp in data:</span><br><span class="line">q.put(tmp)</span><br><span class="line">print(&quot;download OK!&quot;)</span><br><span class="line"></span><br><span class="line">def use(q):</span><br><span class="line">res &#x3D; []</span><br><span class="line">while not q.empty():</span><br><span class="line">res.append(q.get())</span><br><span class="line">print(&quot;res is:&quot;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">q &#x3D; multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">p1 &#x3D; multiprocessing.Process(target&#x3D;download, args&#x3D;(q,))</span><br><span class="line">p2 &#x3D; multiprocessing.Process(target&#x3D;use, args&#x3D;(q,))</span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test02.py</span><br><span class="line">download OK!</span><br><span class="line">res is:</span><br><span class="line">[11, 22, 33, 44]</span><br></pre></td></tr></table></figure><h4 id="4-进程池"><a href="#4-进程池" class="headerlink" title="4.进程池"></a>4.进程池</h4><p>进程的创建和销毁需要消耗很多资源。所以为了减少创建和消耗进程的次数，使用进程池，先创建好固定数量的进程，如果需要执行程序，让这些进程去执行，当执行结束后，把这些进程再放入进程池，这样可以反复利用创建好的进程，不用反复的创建和销毁。</p><p>进程池Pool的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Pool也是在multiprocessing这个包中</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line"># 传递参数，进程池里放多少进程，也可以不传参数</span><br><span class="line">pool &#x3D; Pool(3)</span><br><span class="line"></span><br><span class="line"># pool.apply_async(调用的目标,(传递的参数元组,)) 这里的逗号是必须的。</span><br><span class="line"># 用进程池里空闲的子进程去调用目标，如果当前没有空闲的子进程，任务也会被添加到进程池里，等待子进程空闲的时候去执行</span><br><span class="line">pool.apply_async(work,(i,))</span><br><span class="line"></span><br><span class="line"># 关闭进程池，不再接收新的请求</span><br><span class="line">pool.close()</span><br><span class="line"></span><br><span class="line"># 等待所有的子进程结束再结束程序，必须放在close语句之后，如果没有这句话，不能保证子进程都执行完毕。因为通过进程池创建的子进程，主进程不会自动等待他们执行完毕。</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def work(num):</span><br><span class="line">    print(&quot;------start-------&quot;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(num)</span><br><span class="line">    print(&quot;------end---------&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    pool &#x3D; Pool(3)</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.apply_async(work,(i,))</span><br><span class="line"></span><br><span class="line">    print(&quot;------come to close---------&quot;)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(&quot;------come to an end--------&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ python test03.py</span><br><span class="line">------start-------</span><br><span class="line">2</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">5</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">6</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">0</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">4</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">7</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">1</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">3</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">8</span><br><span class="line">------end---------</span><br><span class="line">------start-------</span><br><span class="line">9</span><br><span class="line">------end---------</span><br><span class="line">------come to close---------</span><br><span class="line">------come to an end--------</span><br></pre></td></tr></table></figure><p>可以看到，进程的调度顺序也是不确定的。</p><h4 id="5-多进程实现复制文件夹下的多个文件"><a href="#5-多进程实现复制文件夹下的多个文件" class="headerlink" title="5.多进程实现复制文件夹下的多个文件"></a>5.多进程实现复制文件夹下的多个文件</h4><p>1.获取要复制的文件夹的名字</p><p>2.创建一个新的文件夹</p><p>3.获取文件夹所有要复制的文件名字</p><p>4.创建进程池，主进程往进程池里添加要复制的文件</p><p>5.子进程把文件复制到新的文件夹中去</p><p>当前有如下文件夹及文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;d&#x2F;test:</span><br><span class="line">$ ls</span><br><span class="line">1.py  2.py  3.py  4.py  5.py  6.py  7.py  8.py  9.py</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def copy(file, old_folder, new_folder):</span><br><span class="line">old_f &#x3D;  open(old_folder + &quot;&#x2F;&quot; + file, &quot;rb&quot;)</span><br><span class="line">content &#x3D; old_f.read()</span><br><span class="line">old_f.close()</span><br><span class="line"></span><br><span class="line">new_f &#x3D; open(new_folder + &quot;&#x2F;&quot; + file, &quot;wb&quot;)</span><br><span class="line">new_f.write(content)</span><br><span class="line">new_folder.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">source_folder &#x3D; &#39;test&#39;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">new_folder &#x3D; source_folder + &quot;_copy&quot;</span><br><span class="line">os.mkdir(new_folder)</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">files &#x3D; os.listdir(source_folder)</span><br><span class="line"></span><br><span class="line">pool &#x3D; multiprocessing.Pool(5)</span><br><span class="line"></span><br><span class="line">for f in files:</span><br><span class="line">pool.apply_async(copy, (f, source_folder, new_folder))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python test04.py</span><br></pre></td></tr></table></figure><p>查看当前目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.py      </span><br><span class="line">test_copy&#x2F;</span><br></pre></td></tr></table></figure><p>已经成功复制了test，进入test_copy目录下，看看文件是否复制成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls test_copy&#x2F;</span><br><span class="line">1.py  2.py  3.py  4.py  5.py  6.py  7.py  8.py  9.py</span><br></pre></td></tr></table></figure><p>已经成功复制了。</p><p>改进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def copy(queue, file, old_folder, new_folder):</span><br><span class="line">old_f &#x3D;  open(old_folder + &quot;&#x2F;&quot; + file, &quot;rb&quot;)</span><br><span class="line">content &#x3D; old_f.read()</span><br><span class="line">old_f.close()</span><br><span class="line"></span><br><span class="line">new_f &#x3D; open(new_folder + &quot;&#x2F;&quot; + file, &quot;wb&quot;)</span><br><span class="line">new_f.write(content)</span><br><span class="line">new_folder.close()</span><br><span class="line">queue.put(file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">source_folder &#x3D; &#39;test&#39;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">new_folder &#x3D; source_folder + &quot;_copy&quot;</span><br><span class="line">os.mkdir(new_folder)</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">files &#x3D; os.listdir(source_folder)</span><br><span class="line"></span><br><span class="line">pool &#x3D; multiprocessing.Pool(5)</span><br><span class="line">queue &#x3D; multiprocessing.Manager().Queue()</span><br><span class="line"></span><br><span class="line">for f in files:</span><br><span class="line">pool.apply_async(copy, (queue, f, source_folder, new_folder))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line"># pool.join()</span><br><span class="line">lenth &#x3D; len(files)</span><br><span class="line">num &#x3D; 0</span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">name &#x3D; queue.get_nowait()</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">num +&#x3D; 1</span><br><span class="line">print(&quot;\r拷贝进度为 %.2f %%&quot; % (num*100&#x2F;lenth), end&#x3D;&quot;&quot;)</span><br><span class="line">if num &gt;&#x3D; lenth:</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><ul><li>这里使用的不是multiprocessing下的Queue，而是multiprocessing下的manager下的Queue。</li><li>结合了进程之间使用Queue进行通信，实现多进程复制文件。</li><li>用一个简单的方式打印了拷贝进度。</li></ul><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test04.py</span><br><span class="line">拷贝进度为 100.00 %</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><h4 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for tmp in a:</span><br><span class="line">   print(tmp)</span><br></pre></td></tr></table></figure><p>如果a是可以在上面的代码里使用的数据类型，a就是可迭代对象。</p><p>元组，列表，字典，集合，字符串都是可迭代的对象。</p><p>如何判断一个对象是否是可迭代的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(要判断的对象，Iterable)</span><br></pre></td></tr></table></figure><p>如果是可迭代的对象会返回一个True，否则返回False。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [5]: from collections import Iterable</span><br><span class="line"></span><br><span class="line">In [6]: a &#x3D; [11,22,33]</span><br><span class="line"></span><br><span class="line">In [7]: isinstance(a, Iterable)</span><br><span class="line">Out[7]: True</span><br></pre></td></tr></table></figure><p>如果想要一个类也变成一个可迭代对象，那么可以在类中添加一个<code>__iter__</code>方法。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassName&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))</span><br></pre></td></tr></table></figure><p>运行这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">test05.py:1: DeprecationWarning: Using or importing the ABCs from &#39;collections&#39; instead of from &#39;collections.abc&#39; is deprecated since Python 3.3,and in 3.9 it will stop working</span><br><span class="line">  from collections import Iterable</span><br><span class="line">判断classmate是否是可迭代对象： False</span><br></pre></td></tr></table></figure><p>提示了collections的用法变了，所以修改一下程序：<br><code>from collections.abc import Iterable</code><br>再次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">判断classmate是否是可迭代对象： False</span><br></pre></td></tr></table></figure><p>这时候给类添加一个<code>__iter__</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassName&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">判断classmate是否是可迭代对象： True</span><br></pre></td></tr></table></figure><p>即使是没有具体实现，只要有这个魔法函数，这个类的实例对象也是可迭代对象。</p><p>这时候就满足了最基本的for循环条件，但是这时候还用不了。这是因为for循环的时候，每次要取一个值，还需要一个东西来记录取到了哪。</p><p>所以<code>__iter__</code>方法必须返回一个对象的引用，这个对象必须要有<code>__iter__</code>和<code>__next__</code>方法，这个对象就是一个迭代器。</p><p>判断一个对象是否是迭代器：</p><ul><li>这时候导入的是collections下的Iterator</li><li>使用<code>iter(对象)</code>方法可以自动调用对象的<code>__iter__</code>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">return ClassIterator()</span><br><span class="line"></span><br><span class="line">class ClassIterator(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot;</span><br><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))</span><br><span class="line"># 因为&#96;__iter__&#96;方法返回的是ClassIterator()的引用，所以&#96;iter()&#96;方法得到的也是ClassIterator()的引用。</span><br><span class="line">classmate_iterator &#x3D; iter(classmate)</span><br><span class="line">print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))</span><br></pre></td></tr></table></figure>运行程序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">判断classmate是否是可迭代对象： True</span><br><span class="line">判断classmate是否是迭代器： True</span><br></pre></td></tr></table></figure>for循环每次调用的是这个对象的<code>__iter__</code>方法返回的另一个对象的引用的<code>__next__</code>方法。</li></ul><p>所以如果使用for循环这个Classmate对象，每次取到的是Classmate对象的<code>__iter__</code>函数返回的ClassIterator对象的引用的<code>__next__</code>方法返回的值。</p><p>也就是如果把<code>__next__</code>的<code>pass</code>改为<code>return 11</code>的话，for循环每次返回的都应该是11。</p><p>修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">return ClassIterator()</span><br><span class="line"></span><br><span class="line">class ClassIterator(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot;</span><br><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">return 11</span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line"># print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))</span><br><span class="line"># classmate_iterator &#x3D; iter(classmate)</span><br><span class="line"># print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))</span><br><span class="line"></span><br><span class="line">for name in classmate:</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>打印11无限循环。</p><p>但是实际上，希望ClassIterator实现的功能是把Classmate的name列表逐个取到，那么就可以在Classmate的<code>__iter__</code>函数返回ClassIterator引用的时候，把Classmate传过去。这样ClassIterator就可以取到name这一个列表。</p><p>修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from collections.abc import Iterable</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">return ClassIterator(self)</span><br><span class="line"></span><br><span class="line">class ClassIterator(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot;</span><br><span class="line">def __init__(self, obj):</span><br><span class="line">self.obj &#x3D; obj</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">return self.obj.name[0]</span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line"># print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))</span><br><span class="line"># classmate_iterator &#x3D; iter(classmate)</span><br><span class="line"># print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))</span><br><span class="line"></span><br><span class="line">for name in classmate:</span><br><span class="line">print(name)</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><p>这时候ClassIterator类可以取到Classmate的name列表。但是每次取到的都是name[0]，想要继续往下取，就需要一个下标，每次取完一次，下标就加一。</p><p>修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from collections.abc import Iterable</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">return ClassIterator(self)</span><br><span class="line"></span><br><span class="line">class ClassIterator(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot;</span><br><span class="line">def __init__(self, obj):</span><br><span class="line">self.obj &#x3D; obj</span><br><span class="line">self.cur_index &#x3D; 0</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">                # 防止下标越界</span><br><span class="line">if self.cur_index &lt; len(self.obj.name):</span><br><span class="line">res &#x3D; self.obj.name[self.cur_index]</span><br><span class="line">self.cur_index +&#x3D; 1</span><br><span class="line">return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line"># print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))</span><br><span class="line"># classmate_iterator &#x3D; iter(classmate)</span><br><span class="line"># print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))</span><br><span class="line"></span><br><span class="line">for name in classmate:</span><br><span class="line">print(name)</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><p>运行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">同学一</span><br><span class="line">同学二</span><br><span class="line">同学三</span><br><span class="line">None</span><br><span class="line">None</span><br><span class="line">None</span><br><span class="line">None</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>这时候会发生一种情况就是，当for已经取完name列表中的所有元素之后，并不会停止，会继续取name的值，但是因为当前的下标已经等于或超过name列表的长度，所以<code>__next__</code>方法没有返回任何值，所以for循环继续，但是每次取到的值都是None。</p><p>所以如果想让for循环结束，需要抛出一个<code>StopIteration</code>异常，for就会结束循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from collections.abc import Iterable</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">return ClassIterator(self)</span><br><span class="line"></span><br><span class="line">class ClassIterator(object):</span><br><span class="line">&quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot;</span><br><span class="line">def __init__(self, obj):</span><br><span class="line">self.obj &#x3D; obj</span><br><span class="line">self.cur_index &#x3D; 0</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">if self.cur_index &lt; len(self.obj.name):</span><br><span class="line">res &#x3D; self.obj.name[self.cur_index]</span><br><span class="line">self.cur_index +&#x3D; 1</span><br><span class="line">return res</span><br><span class="line">else:</span><br><span class="line">raise StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line">for name in classmate:</span><br><span class="line">print(name)</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><p>运行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">同学一</span><br><span class="line">同学二</span><br><span class="line">同学三</span><br></pre></td></tr></table></figure><p>那么Classmate的<code>__iter__</code>可不可以返回自身，这样就不用返回别的类的引用。</p><p>修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from collections.abc import Iterable</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Classmate(object):</span><br><span class="line">&quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot;</span><br><span class="line">def __init__(self):</span><br><span class="line">self.name &#x3D; list()</span><br><span class="line">self.cur_index &#x3D; 0</span><br><span class="line"></span><br><span class="line">def add(self, name):</span><br><span class="line">self.name.append(name)</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">return self</span><br><span class="line"></span><br><span class="line">def __next__(self):</span><br><span class="line">if self.cur_index &lt; len(self.name):</span><br><span class="line">res &#x3D; self.name[self.cur_index]</span><br><span class="line">self.cur_index +&#x3D; 1</span><br><span class="line">return res</span><br><span class="line">else:</span><br><span class="line">raise StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate &#x3D; Classmate()</span><br><span class="line"></span><br><span class="line">classmate.add(&quot;同学一&quot;)</span><br><span class="line">classmate.add(&quot;同学二&quot;)</span><br><span class="line">classmate.add(&quot;同学三&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for name in classmate:</span><br><span class="line">print(name)</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><p>执行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test05.py</span><br><span class="line">同学一</span><br><span class="line">同学二</span><br><span class="line">同学三</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果一个对象是迭代器，那么它一定可以迭代。因为它一定包含<code>__iter__</code>和<code>__next__</code>。</li><li>一个对象可迭代，它不一定是迭代器。<h4 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h4>生成器是一种特殊的迭代器。<br>#####（1）创建生成器的方式</li></ul><p><strong>方法1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; [x*2 for i in range(10)]</span><br></pre></td></tr></table></figure><p>nums会得到一个列表，如果把中括号变为小括号，nums得到的就是一个生成器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">In [11]: nums &#x3D; [ x*2 for x in range(10)]</span><br><span class="line"></span><br><span class="line">In [12]: nums</span><br><span class="line">Out[12]: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span><br><span class="line"></span><br><span class="line">In [13]: nums2 &#x3D; (x*2 for x in range(10))</span><br><span class="line"></span><br><span class="line">In [14]: nums2</span><br><span class="line">Out[14]: &lt;generator object &lt;genexpr&gt; at 0x0000015761EE6DC8&gt;</span><br><span class="line"></span><br><span class="line">In [15]: for i in nums:</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">In [16]: for i in nums2:</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p>生成器和列表都可以用for遍历。<br><strong>方法2：</strong></p><p>把函数变为生成器。</p><p>只要函数里有<code>yield</code>，那么这个函数就会变成生成器。</p><p>如果想得到斐波那契数列的前多少位，可以这样来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line">print(a)</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">worker(10)</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br></pre></td></tr></table></figure><p>如果把print改为yield，那么这个函数就变成了一个生成器。调用这个生成器的方式和原来调用函数的方式不同。如果这时候还使用<code>worker(10)</code>的方式，不是在调用函数，而是在创建一个生成器对象。在使用for循环遍历这个生成器对象，就可以每次取到一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line"># print(a)</span><br><span class="line">yield a</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">for i in obj:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>执行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br></pre></td></tr></table></figure><p>for从obj里逐个取值的时候，第一次从worker的开始执行，执行到yield把a的值返回，然后第二次for再取值的时候，不是从worker的头开始执行，而是从上一次yield停止的位置继续往下执行。</p><p>如果每次只想取一个值打印出来，可以使用next：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line"># print(a)</span><br><span class="line">yield a</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>next会取到当前yield后面的值，然后下次调用再取下一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>也就是想让生成器执行，要使用next让他执行，而不是调用生成器。</p><p>如果创建的是多个生成器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line"># print(a)</span><br><span class="line">yield a</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">obj2 &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj2)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res &#x3D; next(obj2)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>两个生成器对象之间互相没有影响。</p><p><strong>生成器的结束</strong><br>还是使用异常让生成器结束遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line"># print(a)</span><br><span class="line">yield a</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(2)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">print(next(obj))</span><br><span class="line">except Exception as res:</span><br><span class="line">break</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>如果这个生成器有返回值，可以用下面的方式得到它的返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line"># print(a)</span><br><span class="line">yield a</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line">return &quot;OK!&quot;</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">print(next(obj))</span><br><span class="line">except Exception as res:</span><br><span class="line">print(res.value)</span><br><span class="line">break</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">OK!</span><br></pre></td></tr></table></figure><p><strong>生成器的启动还可以用send</strong><br>用法：<code>生成器对象.sen(参数)</code></p><p>程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line">res &#x3D; yield a</span><br><span class="line">print(res)</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">print(next(obj))</span><br><span class="line">print(obj.send(&quot;haha&quot;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br><span class="line">haha</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>执行过程：<br>当用next启动生成器的时候，从worker的头开始执行，执行到<code>yield a</code>把a的值返回，然后打印出来。当send启动生成器的时候，系统从上一次yield的位置接着往下执行，执行到的第一条语句是把yield a 的值赋给res，yield a的值就是send中传递的参数，这时候res = “haha”，然后程序继续往下执行，打印出这个res。</p><p>send与next相比，优点就是可以传递参数。</p><p>send如果传递了参数不能一开始就调用，调用，会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line">res &#x3D; yield a</span><br><span class="line">print(res)</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">print(obj.send(&quot;haha&quot;))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test06.py&quot;, line 12, in &lt;module&gt;</span><br><span class="line">    print(obj.send(&quot;haha&quot;))</span><br><span class="line">TypeError: can&#39;t send non-None value to a just-started generator</span><br></pre></td></tr></table></figure><p>如果没有参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def worker(tmp):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">cur &#x3D; 0</span><br><span class="line">while cur &lt; tmp:</span><br><span class="line">res &#x3D; yield a</span><br><span class="line">print(res)</span><br><span class="line">a , b &#x3D; b, a+b</span><br><span class="line">cur +&#x3D; 1</span><br><span class="line"></span><br><span class="line">obj &#x3D; worker(10)</span><br><span class="line"></span><br><span class="line">print(obj.send(None))</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test06.py</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>#####（2）使用yield实现多任务（协程实现多任务）<br>只要在函数里面写上<code>yield</code>，函数就变成了一个生成器，再创建生成器对象，调用next即可。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def task01():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;task01&quot;)</span><br><span class="line">time.sleep(1)</span><br><span class="line">yield</span><br><span class="line"></span><br><span class="line">def task02():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;task02&quot;)</span><br><span class="line">time.sleep(1)</span><br><span class="line">yield</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">t1 &#x3D; task01()</span><br><span class="line">t2 &#x3D; task02()</span><br><span class="line">while True:</span><br><span class="line">next(t1)</span><br><span class="line">next(t2)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test07.py</span><br><span class="line">task01</span><br><span class="line">task02</span><br><span class="line">task01</span><br><span class="line">task02</span><br><span class="line">task01</span><br><span class="line">task02</span><br><span class="line">task01</span><br><span class="line">task02</span><br><span class="line">task01</span><br><span class="line">task02</span><br><span class="line">task01</span><br><span class="line">task02</span><br></pre></td></tr></table></figure><p>这是一个协程的并发（假的“一起”执行）。<br>#####（3）使用greenlet、gevent实现多任务（协程实现多任务）<br>使用greenlet可以替换yield。</p><p>要使用greenlet需要导入：<br><code>from greenlet import greenlet</code><br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;test1&quot;)</span><br><span class="line"># 切换到gr2去执行</span><br><span class="line">gr2.switch()</span><br><span class="line">time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">while True:</span><br><span class="line">print(&quot;test2&quot;)</span><br><span class="line"># 切换到gr1去执行</span><br><span class="line">gr1.switch()</span><br><span class="line">time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"># 返回值是一个greenlet对象</span><br><span class="line">gr1 &#x3D; greenlet(test1)</span><br><span class="line">gr2 &#x3D; greenlet(test2)</span><br><span class="line"></span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test07.py</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test1</span><br><span class="line">test2</span><br></pre></td></tr></table></figure><p>greenlet的切换是在单线程内切换，而如果想要切换到其他的协程，真正实现多任务，就需要用到gevent。</p><p>gevent也需要导入：<br><code>import gevent</code><br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test(n):</span><br><span class="line">for i in range(n):</span><br><span class="line">print(gevent.getcurrent(), i)</span><br><span class="line"></span><br><span class="line"># 指定去哪执行</span><br><span class="line">g1 &#x3D; gevent.spawn(test, 5)</span><br><span class="line">g2 &#x3D; gevent.spawn(test, 5)</span><br><span class="line">g3 &#x3D; gevent.spawn(test, 5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test07.py</span><br><span class="line">&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 4</span><br><span class="line">&lt;Greenlet at 0x158e6514048: test(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x158e6514048: test(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x158e6514048: test(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x158e6514048: test(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x158e6514048: test(5)&gt; 4</span><br><span class="line">&lt;Greenlet at 0x158e6514378: test(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x158e6514378: test(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x158e6514378: test(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x158e6514378: test(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x158e6514378: test(5)&gt; 4</span><br></pre></td></tr></table></figure><p>在greenlet中，遇到延时，程序会等待这个延时结束，再去切换另一个任务，而gevent遇到延时就会自动切换。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def test01(n):</span><br><span class="line">for i in range(n):</span><br><span class="line">print(gevent.getcurrent(), i)</span><br><span class="line">gevent.sleep(0.5)</span><br><span class="line"></span><br><span class="line">def test02(n):</span><br><span class="line">for i in range(n):</span><br><span class="line">print(gevent.getcurrent(), i)</span><br><span class="line">gevent.sleep(0.5)</span><br><span class="line"></span><br><span class="line">def test03(n):</span><br><span class="line">for i in range(n):</span><br><span class="line">print(gevent.getcurrent(), i)</span><br><span class="line">gevent.sleep(0.5)</span><br><span class="line"></span><br><span class="line">g1 &#x3D; gevent.spawn(test01, 5)</span><br><span class="line">g2 &#x3D; gevent.spawn(test02, 5)</span><br><span class="line">g3 &#x3D; gevent.spawn(test03, 5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test07.py</span><br><span class="line">&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 4</span><br><span class="line">&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 4</span><br><span class="line">&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 4</span><br></pre></td></tr></table></figure><p>如果是三个协程执行的是同一份代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def test01(n):</span><br><span class="line">for i in range(n):</span><br><span class="line">print(gevent.getcurrent(), i)</span><br><span class="line">gevent.sleep(0.5)</span><br><span class="line"></span><br><span class="line">g1 &#x3D; gevent.spawn(test01, 5)</span><br><span class="line">g2 &#x3D; gevent.spawn(test01, 5)</span><br><span class="line">g3 &#x3D; gevent.spawn(test01, 5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;python test07.py</span><br><span class="line">&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 3</span><br><span class="line">&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 4</span><br><span class="line">&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 4</span><br><span class="line">&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 4</span><br></pre></td></tr></table></figure><p>先打印了每个协程的0，然后打印了1、2、3、4。</p><p>所以gevent在有延迟的时候，自动切换了。</p><p>协程依赖与线程，线程依赖于线程。</p><h3 id="进程、线程、协程对比"><a href="#进程、线程、协程对比" class="headerlink" title="进程、线程、协程对比"></a>进程、线程、协程对比</h3><ul><li>进程是资源分配的基本单位，多进程耗费资源最多。</li><li>多线程的程序，同一时间只有一个线程在运行。</li><li>在不考虑GIL的前提下，优先考虑线程，再考虑协程，再考虑进程。</li><li>协程利用进程在等待的时间去做别的事情，协程切换资源消耗小，效率高。</li><li>进程最稳定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Python深拷贝浅拷贝</title>
      <link href="/2020/08/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/08/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>所谓拷贝，就是复制。</p><p>深拷贝，就是复制的比较多，浅拷贝，就是复制的比较少。</p><a id="more"></a><p>在Python中，copy.copy可以完成浅拷贝，copy.deepcopy可以完成深拷贝。</p><h4 id="举例-图解"><a href="#举例-图解" class="headerlink" title="举例 图解"></a>举例 图解</h4><h5 id="1-赋值"><a href="#1-赋值" class="headerlink" title="1.赋值"></a>1.赋值</h5><p>如果 a = [11,22]， 把a赋给b：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a &#x3D; [11, 22]</span><br><span class="line">In [2]: b &#x3D; a</span><br><span class="line"></span><br><span class="line">In [3]: a</span><br><span class="line">Out[3]: [11, 22]</span><br><span class="line"></span><br><span class="line">In [4]: b</span><br><span class="line">Out[4]: [11, 22]</span><br></pre></td></tr></table></figure><p>从结果来看是看不出来a和b是否是同一个，我们用id()函数查看一下a和b的id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [5]: id(a)</span><br><span class="line">Out[5]: 2293026594376</span><br><span class="line"></span><br><span class="line">In [6]: id(b)</span><br><span class="line">Out[6]: 2293026594376</span><br></pre></td></tr></table></figure><p>a 和 b的id相同，说明他们指向了同一块区域，这里说指向，是因为在Python中，实际上是有一个空间存储了[11, 22]，在给a赋值的时候，变量名a就指向了[11,22]的空间，当把a赋给b的时候，实际上是让b也指向[11,22]。</p><p>画图来说明是这样的：</p><p><img src="https://i.loli.net/2020/08/11/KVH6Qm7kb5go1C3.png" alt="image.png"></p><h5 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2.浅拷贝"></a>2.浅拷贝</h5><p>在python中，copy.copy()可以用来浅拷贝，copy.deepcopy()可以用来深拷贝。</p><p>重新定义了a，b，然后把a和b作为一个列表赋给c。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [11]: a &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">In [12]: b &#x3D; [33,44]</span><br><span class="line"></span><br><span class="line">In [13]: c &#x3D; [a, b]</span><br></pre></td></tr></table></figure><p>这时候相当于：<br><img src="https://i.loli.net/2020/08/11/VLTkwK2ltmAigZu.png" alt="image.png"><br>验证一下：</p><p>如果a与c[0]的id相同，就说明他们指向的是相同的区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [14]: id(a)</span><br><span class="line">Out[14]: 2293027197896</span><br><span class="line"></span><br><span class="line">In [15]: id(c[0])</span><br><span class="line">Out[15]: 2293027197896</span><br></pre></td></tr></table></figure><p>如果现在把c赋给d：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [16]: d &#x3D; c</span><br></pre></td></tr></table></figure><p>这相当于：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-6a0f58d19d02459f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [17]: id(d)</span><br><span class="line">Out[17]: 2293026531656</span><br><span class="line"></span><br><span class="line">In [18]: id(c)</span><br><span class="line">Out[18]: 2293026531656</span><br></pre></td></tr></table></figure><p>如果这时候把c浅拷贝给e：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [19]: import copy</span><br><span class="line"></span><br><span class="line">In [20]: e &#x3D; copy.copy(c)</span><br></pre></td></tr></table></figure><p>这时候，e会指向一块新开辟的区域。<br><img src="https://i.loli.net/2020/08/11/swI8DXcyP32hoFC.png" alt="image.png"></p><p>因为是浅拷贝，所以e的这块区域也会指向c的区域的指向，也就是这样：</p><p><img src="https://i.loli.net/2020/08/11/sc52XwHd7I6epAq.png" alt="image.png"></p><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [21]: id(e)</span><br><span class="line">Out[21]: 2293027309192</span><br><span class="line"></span><br><span class="line">In [22]: id(c)</span><br><span class="line">Out[22]: 2293026531656</span><br><span class="line"></span><br><span class="line">In [23]: id(e[0])</span><br><span class="line">Out[23]: 2293027197896</span><br><span class="line"></span><br><span class="line">In [24]: id(c[0])</span><br><span class="line">Out[24]: 2293027197896</span><br></pre></td></tr></table></figure><p>e和c的地址不同，说明e和c指向的区域不一样，e[0]和c[0]的id相同，说明他们指向了同一块空间。</p><p>这就是浅拷贝，它只拷贝了第一层，第二层以下的数据并没有真的“拷贝”出来。</p><p>当前的a，b和c，e：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [25]: a</span><br><span class="line">Out[25]: [11, 22]</span><br><span class="line"></span><br><span class="line">In [26]: b</span><br><span class="line">Out[26]: [33, 44]</span><br><span class="line"></span><br><span class="line">In [27]: c</span><br><span class="line">Out[27]: [[11, 22], [33, 44]]</span><br><span class="line"></span><br><span class="line">In [28]: e</span><br><span class="line">Out[28]: [[11, 22], [33, 44]]</span><br></pre></td></tr></table></figure><p>因为是浅拷贝，所以如果a修改了，e也会修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [30]: a</span><br><span class="line">Out[30]: [11, 22, &#39;hahaha&#39;]</span><br><span class="line"></span><br><span class="line">In [31]: c</span><br><span class="line">Out[31]: [[11, 22, &#39;hahaha&#39;], [33, 44]]</span><br><span class="line"></span><br><span class="line">In [32]: e</span><br><span class="line">Out[32]: [[11, 22, &#39;hahaha&#39;], [33, 44]]</span><br></pre></td></tr></table></figure><p>a = [11,22] c = [a,b]，再来看看深拷贝。</p><h5 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3.深拷贝"></a>3.深拷贝</h5><p>如果是深拷贝，就原原本本的把所有层的数据都拷贝一份新的，指向也指向这份新的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [44]: f &#x3D; copy.deepcopy(c)</span><br><span class="line"></span><br><span class="line">In [45]: c</span><br><span class="line">Out[45]: [[11, 22], [33, 44]]</span><br><span class="line"></span><br><span class="line">In [46]: f</span><br><span class="line">Out[46]: [[11, 22], [33, 44]]</span><br></pre></td></tr></table></figure><p>这时候的指向是这样的：<br><a href="https://sm.ms/image/aq8tfyV3WoB7Cip" target="_blank"><img src="https://i.loli.net/2020/08/11/aq8tfyV3WoB7Cip.png" ></a></p><p>验证：<br>如果c和f，c[0]和f[0]的地址不同，说明是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [47]: id(c)</span><br><span class="line">Out[47]: 2293026784840</span><br><span class="line"></span><br><span class="line">In [48]: id(f)</span><br><span class="line">Out[48]: 2293027611400</span><br><span class="line"></span><br><span class="line">In [49]: id(c[0])</span><br><span class="line">Out[49]: 2293027354312</span><br><span class="line"></span><br><span class="line">In [50]: id(f[0])</span><br><span class="line">Out[50]: 2293027035208</span><br></pre></td></tr></table></figure><h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p>所以不管是copy还是deepcopy，都会先创建一份新的空间，而直接赋值<code>b=a</code>则不会。</p><h4 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>前提如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [53]: a &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">In [54]: b &#x3D; [33,44]</span><br><span class="line"></span><br><span class="line">In [55]: c &#x3D; [a, b]</span><br><span class="line"></span><br><span class="line">In [56]: d &#x3D; copy.copy(c)</span><br><span class="line"></span><br><span class="line">In [57]: e &#x3D; copy.deepcopy(c)</span><br></pre></td></tr></table></figure><p><strong>如果这时候在c中append一个新的列表[55,66]d和e会如何变化？</strong></p><p>查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [58]: c.append([55,66])</span><br><span class="line"></span><br><span class="line">In [59]: d</span><br><span class="line">Out[59]: [[11, 22], [33, 44]]</span><br><span class="line"></span><br><span class="line">In [60]: e</span><br><span class="line">Out[60]: [[11, 22], [33, 44]]</span><br></pre></td></tr></table></figure><p>原因图解如下：<br>一开始的指向是这样的：<br><a href="https://sm.ms/image/XPSYtxybcGADia6" target="_blank"><img src="https://i.loli.net/2020/08/11/XPSYtxybcGADia6.png" ></a></p><p>或者把d放在上面更直观一些：<br><a href="https://sm.ms/image/tFH4j6XQc51TVE8" target="_blank"><img src="https://i.loli.net/2020/08/11/tFH4j6XQc51TVE8.png" ></a></p><p>这时候在c中添加新的列表：<br><a href="https://sm.ms/image/cylOhQb23KSqfXv" target="_blank"><img src="https://i.loli.net/2020/08/11/cylOhQb23KSqfXv.png" ></a></p><p>实际上的这个添加和d和e是没有任何关系的，所以才会有这样的结果，因为d已经拷贝完了，拷贝完之后才添加的，所以d中不会有[55,66]。</p><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><p>前提：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [70]: a &#x3D; (11,22)</span><br><span class="line"></span><br><span class="line">In [71]:  b &#x3D; copy.copy(a)</span><br></pre></td></tr></table></figure><p>把a浅拷贝给b，这时候a是一个元组。</p><p>来查看a和b的id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [73]: id(a)</span><br><span class="line">Out[73]: 2293027979080</span><br><span class="line"></span><br><span class="line">In [74]: id(b)</span><br><span class="line">Out[74]: 2293027979080</span><br></pre></td></tr></table></figure><p>发现他们的地址是一样的。</p><p>所以如果浅拷贝发现拷贝对象是一个元组，就直接不拷贝了，变为了指向。</p><p>因为元组是不可变类型，数据不会被修改。</p><p>如果是深拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [75]: c &#x3D; copy.deepcopy(a)</span><br></pre></td></tr></table></figure><p>这时候查看c的id和a的id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [76]: id(c)</span><br><span class="line">Out[76]: 2293027979080</span><br><span class="line"></span><br><span class="line">In [77]: id(a)</span><br><span class="line">Out[77]: 2293027979080</span><br></pre></td></tr></table></figure><p>他们的地址相同，说明深拷贝也没有拷贝。</p><p>再看一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [79]: a &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">In [80]: b &#x3D; [33,44]</span><br><span class="line"></span><br><span class="line">In [81]: c &#x3D; (a,b)</span><br><span class="line"></span><br><span class="line">In [82]: d &#x3D; copy.copy(c)</span><br><span class="line"></span><br><span class="line">In [83]: e &#x3D; copy.deepcopy(c)</span><br></pre></td></tr></table></figure><p>此时a和b都是可变的列表，c是不可变的元组，d有了c的浅拷贝，e有了d的深拷贝。</p><p>这时候d和e有没有拷贝c？</p><p>来查看一下id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [84]: id(c)</span><br><span class="line">Out[84]: 2293028072520</span><br><span class="line"></span><br><span class="line">In [85]: id(d)</span><br><span class="line">Out[85]: 2293028072520</span><br><span class="line"></span><br><span class="line">In [86]: id(e)</span><br><span class="line">Out[86]: 2293027609416</span><br></pre></td></tr></table></figure><p>说明浅拷贝还是没有拷贝，还是指向，但深拷贝拷贝了。<br>所以：</p><ul><li>如果拷贝的是一个元组（第一层是元组），而且元组中都是不可变对象，那么copy模块不管是深拷贝还是浅拷贝都变为了指向（引用）。</li><li>如果拷贝的是一个元组（第一层是元组），不管元组中的对象可变还是不可变，浅拷贝都直接指向，而不开辟新的空间了。</li><li>如果拷贝的是一个元组（第一层是元组），元组中有可变对象，那么深拷贝还是会开辟新的空间，把每一层的数据都拷贝了。</li><li>所以当深拷贝的时候，如果每一层的元素都是不可变对象，那深拷贝也不拷贝了，变为了指向，但是不管哪一层的数据，只要有一个是可变对象，那么深拷贝就会递归的把所有的数据都拷贝一份。</li></ul><h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><p>切片是浅拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [88]: a &#x3D; [11,22]</span><br><span class="line"></span><br><span class="line">In [89]: b &#x3D; [33,44]</span><br><span class="line"></span><br><span class="line">In [90]: c &#x3D; [a,b]</span><br><span class="line"></span><br><span class="line">In [91]: d &#x3D; c[:]</span><br><span class="line"></span><br><span class="line">In [92]: id(c)</span><br><span class="line">Out[92]: 2293027355592</span><br><span class="line"></span><br><span class="line">In [93]: id(d)</span><br><span class="line">Out[93]: 2293026561416</span><br><span class="line"></span><br><span class="line">In [94]: a.append(&quot;lalala&quot;)</span><br><span class="line"></span><br><span class="line">In [95]: a</span><br><span class="line">Out[95]: [11, 22, &#39;lalala&#39;]</span><br><span class="line"></span><br><span class="line">In [96]: c</span><br><span class="line">Out[96]: [[11, 22, &#39;lalala&#39;], [33, 44]]</span><br><span class="line"></span><br><span class="line">In [97]: d</span><br><span class="line">Out[97]: [[11, 22, &#39;lalala&#39;], [33, 44]]</span><br></pre></td></tr></table></figure><h5 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h5><p>字典中的拷贝。<br>字典有一个copy方法，用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.copy()</span><br></pre></td></tr></table></figure><p>这个拷贝是一个浅拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [100]: first &#x3D; &#123;&quot;a&quot;:[1,2],&quot;b&quot;:33&#125;</span><br><span class="line"></span><br><span class="line">In [101]: second &#x3D; first.copy()</span><br></pre></td></tr></table></figure><p>查看一下两个字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [102]: first</span><br><span class="line">Out[102]: &#123;&#39;a&#39;: [1, 2], &#39;b&#39;: 33&#125;</span><br><span class="line"></span><br><span class="line">In [103]: second</span><br><span class="line">Out[103]: &#123;&#39;a&#39;: [1, 2], &#39;b&#39;: 33&#125;</span><br></pre></td></tr></table></figure><p>如果这时候[11,22]列表中添加一个新的值3，再查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [104]: first[&#39;a&#39;].append(3)</span><br><span class="line"></span><br><span class="line">In [105]: first</span><br><span class="line">Out[105]: &#123;&#39;a&#39;: [1, 2, 3], &#39;b&#39;: 33&#125;</span><br><span class="line"></span><br><span class="line">In [106]: second</span><br><span class="line">Out[106]: &#123;&#39;a&#39;: [1, 2, 3], &#39;b&#39;: 33&#125;</span><br></pre></td></tr></table></figure><p>说明是浅拷贝。</p><p>补充说明：</p><p>字典的key是保存在字典里的，value才是指向。<br><a href="https://sm.ms/image/mAhrMaG8g54ipv2" target="_blank"><img src="https://i.loli.net/2020/08/11/mAhrMaG8g54ipv2.png" ></a></p><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><p>在python中，像11这样的值的类型的数据在只会创建一个，所以如果a=[11,22],b=[11,22]，实际指向是这样的：<br><a href="https://sm.ms/image/ReXWoJVfcaHl6v5" target="_blank"><img src="https://i.loli.net/2020/08/11/ReXWoJVfcaHl6v5.png" ></a></p><p>所以图解的部分画的图并不准确，可以重新看一下~</p><p>补充部分可以参考：<br><a href="https://www.cnblogs.com/shiyublog/p/10809953.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/shiyublog/p/10809953.html#_label3</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天两道算法题(中等)(6)(Leetcode 200 695)</title>
      <link href="/2020/08/06/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(6)/"/>
      <url>/2020/08/06/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(6)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><ul><li>每当遇到一个“1”，也就是遇到一个岛屿，就把统计岛屿数量的res+1，然后把这个点变为“0”，再遍历这个点相连的所有的1，把这些1都变为0，这样下次再遇到这个岛屿的点就不用再遍历了。<a id="more"></a>这是整体实现的一个想法，具体如下：</li><li>遍历这个grid，如果遇到“1”，也就是遇到了岛屿，就把结果res加一，把当前的“1”置为“0”，再把当前的下标放到cur列表中</li><li>遍历cur，每次把它的第一个节点pop出来，这样我们得到了一个坐标，遍历这个坐标的上下左右，如果上下左右没有越界，而且上下左右有为“1”的，把坐标append到cur中，把“1”置为“0”</li><li>这样当cur遍历结束后，当前岛屿所有的“1”都被置为了“0”</li></ul><p>注意：grid中的所有元素都是字符，不是数字。<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">"1"</span>:</span><br><span class="line">                    cur = [(i, j)]</span><br><span class="line">                    grid[i][j] = <span class="string">"0"</span></span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> cur:</span><br><span class="line">                        m,n = cur.pop(<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>)]:</span><br><span class="line">                            tmp_i = x + m</span><br><span class="line">                            tmp_j = y + n</span><br><span class="line">                            <span class="keyword">if</span> tmp_i &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp_i &lt; len(grid) <span class="keyword">and</span> tmp_j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp_j &lt; len(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[tmp_i][tmp_j] == <span class="string">"1"</span>:</span><br><span class="line">                                cur.append((tmp_i,tmp_j))</span><br><span class="line">                                grid[tmp_i][tmp_j] = <span class="string">"0"</span>           </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695. 岛屿的最大面积</a></p><ul><li>这道题比起上一道题只是维护的res不同，这一道维护的res是岛屿的面积而不是数量了。</li><li>用tmp来记录当前岛屿的面积，遍历完当前岛屿之后，将当前岛屿的面积tmp和res中较大的那个赋给res<br>代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    cur = [(i,j)]</span><br><span class="line">                    grid[i][j] = <span class="number">0</span></span><br><span class="line">                    tmp = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> cur:</span><br><span class="line">                        i,j = cur.pop(<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>)]:</span><br><span class="line">                            tmp_i = i + x</span><br><span class="line">                            tmp_j = j + y</span><br><span class="line">                            <span class="keyword">if</span> tmp_i &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp_i &lt; len(grid) <span class="keyword">and</span> tmp_j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp_j &lt; len(grid[<span class="number">0</span>]):</span><br><span class="line">                                <span class="keyword">if</span> grid[tmp_i][tmp_j] == <span class="number">1</span>:</span><br><span class="line">                                    cur.append((tmp_i,tmp_j))</span><br><span class="line">                                    tmp += <span class="number">1</span></span><br><span class="line">                                    grid[tmp_i][tmp_j] = <span class="number">0</span></span><br><span class="line">                    res = max(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天两道算法题(中等)(5)(Leetcode 15 18)</title>
      <link href="/2020/08/05/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(5)/"/>
      <url>/2020/08/05/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(5)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p><ul><li>把数组先排序，然后遍历这个数组</li><li>因为数组已经排好序，所以遍每当遍历到一个新的元素，可以排除几种情况<ul><li>如果当前的数是nums[i]，如果nums[i]+nums[i+1]+nums[i+2]的值都比0大，说明后面的元素已经不可能有三个数的和等于0了，可以break掉循环</li><li>如果当前的数加上排好序数组的倒数第一个和倒数第二个数的值的和比0还小，也就是当前的值加上数组中最大的两个值还小于0，那么直接continue，遍历下一个值</li><li>如果当前的下标大于0，而且nums[i] == nums[i - 1]，也就是当前的数等于它前一个数，那么也之间continue不找这个数的组合了，因为结果集中要求没有重复的三原组<a id="more"></a></li></ul></li><li>然后设置两个下标值，一个left，一个right，让left从i的下一个值开始往后遍历，让right从数组的末尾开始往前遍历</li><li>计算当前的tmp值，tmp = nums[i]+nums[left]+nums[right]<ul><li>如果当前的tmp比0大，说明right找大了，把right-1</li><li>如果当前的tmp比0小，说明left找小了，把left+1</li><li>如果当前的tmp为0，说明当前是一个结果，把[nums[i],nums[left],nums[right]]这个列表append到结果集中（结果集res = []）<ul><li>如果当前的left &lt; right，那么继续找不同的left和right</li><li>这时候要做一件事情是去重，找到第一个不和刚才的right值相同的right</li><li>找到第一个不和刚才的left的值相同的left</li><li>这一块看代码的时候要注意一下</li></ul></li></ul></li><li>最后返回结果集<br>代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 因为要给left和right留位置，所以只遍历到len(nums)-2的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[len(nums) - <span class="number">1</span>] + nums[len(nums) - <span class="number">2</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                tmp = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="comment"># left如果和left-1的值不同，说明当前的left已经和之前的值不一样了</span></span><br><span class="line">                    <span class="comment"># 但是right因为边界的问题，与之进行比较的right-1，所以当right的值和right-1的值不同时，right当前的值是最后一个与之前right相等的值</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 所以到这里right还要-1</span></span><br><span class="line">                    <span class="comment"># 这里说的left的值和right的值等价于nums[left]和nums[right]</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></p><ul><li>总体上和三数之和的思路差不多</li></ul><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 第一个区别是遍历到len(nums)-3就结束了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[len(nums) - <span class="number">1</span>] + nums[len(nums) - <span class="number">2</span>] + nums[len(nums) - <span class="number">3</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 第二个是这里嵌套了循环，上面的循环是用来找第一个数，下面的循环用来找第二个和第三个数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 这里有一个需要去重的地方，注意是j &gt; i + 1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    tmp = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> tmp == target:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> tmp &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天两道算法题(中等)(4)(Leetcode 46 47)</title>
      <link href="/2020/08/04/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(4)/"/>
      <url>/2020/08/04/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(4)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><p>和之前的所有本系列的题的解法一致~</p><a id="more"></a><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>回溯法：</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, [], [], len(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, tmp, res, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(tmp) == n:</span><br><span class="line">            res.append(copy.deepcopy(tmp))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            self.helper(nums[:i]+nums[i+<span class="number">1</span>:], tmp, res, n)</span><br><span class="line">            tmp.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, [], [], len(nums))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, res, tmp, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(tmp) == n:</span><br><span class="line">            res.append(copy.deepcopy(tmp))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            self.helper(nums[:i] + nums[i+<span class="number">1</span>:], res, tmp, n)</span><br><span class="line">            tmp.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天两道算法题(中等)(3)(Leetcode 78 90)</title>
      <link href="/2020/08/03/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(3)/"/>
      <url>/2020/08/03/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(3)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a><br>难度：中等</p><a id="more"></a><ul><li>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>初始化res数组作为返回的结果集，初始化为[[]]，也就是第一个返回的结果为空数组。</p></li><li><p>然后遍历整数数组nums，每遍历到一个值，就把res中所有的结果加上这个当前的数组值，然后把这些所有的可能加到res中</p></li><li><p>例如遍历到1，当前res中只有一个空数组，那么把空数组+[1]，作为一个结果append到res中，这时res为[[],[1]]</p></li><li><p>遍历到2，当前res为[[],[1]]，把res中的所有可能加上[2]，就得到[2],[1,2]，把这些结果加到res中，res变为[[],[1],[2],[1,2]]</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res &#x3D; [[]]</span><br><span class="line">        for i in nums:</span><br><span class="line">            # res[:]复制了一份副本</span><br><span class="line">            for subset in res[:]:</span><br><span class="line">                res.append(subset + [i])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></li></ul><p>回溯法：<br>和组合总和系列的题解法一样~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, [], [])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, tmp, res)</span>:</span></span><br><span class="line">        res.append(copy.deepcopy(tmp))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            self.helper(nums[i+<span class="number">1</span>:], tmp, res)</span><br><span class="line">            tmp.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a><br>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>回溯法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, [], [])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, tmp, res)</span>:</span></span><br><span class="line">        res.append(copy.deepcopy(tmp))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            self.helper(nums[i+<span class="number">1</span>:], tmp, res)</span><br><span class="line">            tmp.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天两道算法题(中等)(2)(Leetcode 216 77)</title>
      <link href="/2020/08/02/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(2)/"/>
      <url>/2020/08/02/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(2)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a><br>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><a id="more"></a><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><ul><li>这道题和组合总和1、2差不多，只不过不再遍历数组，而是一个数字范围。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:</span><br><span class="line">        if k &#x3D;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line">        return self.helper(1, [], [], k, n)</span><br><span class="line">    </span><br><span class="line">    def helper(self, num, tmp, res, k, n):</span><br><span class="line">        if k &#x3D;&#x3D; 0 and n &#x3D;&#x3D; 0:</span><br><span class="line">            res.append(copy.deepcopy(tmp))</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line">        for i in range(num, 10):</span><br><span class="line">            if i &lt;&#x3D; n:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">                self.helper(i+1, tmp, res, k-1, n - i)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a><br>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>相同思路<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combine(self, n: int, k: int) -&gt; List[List[int]]:</span><br><span class="line">        if k &#x3D;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line">        return self.helper(k, [], [], n, 1)</span><br><span class="line">    </span><br><span class="line">    def helper(self, k, tmp, res, n, i):</span><br><span class="line">        if len(tmp) &#x3D;&#x3D; k:</span><br><span class="line">            res.append(copy.deepcopy(tmp))</span><br><span class="line">            return res</span><br><span class="line">        for i in range(i, n+1):</span><br><span class="line">            if i &lt;&#x3D; n:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">                self.helper(k, tmp, res, n, i+1)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天两道算法题(中等)(1)(Leetcode 39 40)</title>
      <link href="/2020/08/01/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(1)/"/>
      <url>/2020/08/01/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(1)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Backtracking(回溯算法)：<br>三步：</p><ul><li>设置现场</li><li>DFS（递归）</li><li>回复现场（恢复现场）<a id="more"></a></li></ul><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>先实现这个递归，遍历给定的数组，如果遍历到当前元素比target大，直接遍历下一个元素，如果当前的元素值比target小或相等，那么就递归到下一层找第二个数</p></li><li><p>遍历给定的数组，如果当前元素&lt;=target，说明当前的元素有可能是结果中的一个，把当前这个元素放到临时的tmp列表中，然后遍历下一层</p></li><li><p>传递给下一层的值有candidates，因为需要继续遍历，但是传递给下一层的candidates不是完整的candidates，而是从当前元素开始的所有后面的candidates部分，因为如果遍历到3的时候，3为第一个元素，继续往下一层遍历是希望找到candidates3开始后面的元素是否有可能为结果的</p></li><li><p>传递给下一层的target要减去当前的candidates[i]，因为到下一层要判断target是否为0，如果为0说明当前的tmp就是一种结果，需要把tmp添加到res中</p></li><li><p>遍历后tmp需要pop掉这一层添加的节点是恢复现场，例如如果从头开始遍历，tmp为[]，target为7，遍历到第一层，tmp为[2],target为5，遍历到下一层,tmp为[2,2],target为3，继续下一层，tmp为[2,2,2],target为1，再遍历到下一层的时候第一个元素2已经大于target1了，所以直接返回，这时候返回到上一次，pop掉最后一个元素2,tmp变为[2,2]，当前的target为3，然后for循环遍历到3，因为3&lt;=target，所以tmp变为[2,2,3]，target传递给下一层为0，下一层会判断target为0，将tmp列表append到res中去</p></li><li><p>这里需要用到深拷贝，因为tmp在不断被修改，如果用浅拷贝，最后tmp会被修改为[]，这时候res中被append进的tmp也会变为[]</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        if not candidates:</span><br><span class="line">            return []</span><br><span class="line">        return self.helper(candidates, [], [], target)</span><br><span class="line"></span><br><span class="line">    def helper(self, candidates, tmp, res, target):</span><br><span class="line">        if target &#x3D;&#x3D; 0:</span><br><span class="line">            res.append(copy.deepcopy(tmp))</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line">        for i in range(len(candidates)):</span><br><span class="line">            if candidates[i] &lt;&#x3D; target:</span><br><span class="line">                tmp.append(candidates[i])</span><br><span class="line">                self.helper(candidates[i:], tmp, res,target - candidates[i])</span><br><span class="line">                tmp.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>和组合1的区别：<ul><li>一个是在向下传递的时候，因为不能用重复的数字，所以向下传递的candidates[i:]变为了candidates[i+1:]</li><li>另一个是遍历到当前层，如果当前的列表元素值和前一个元素值相等，那就不遍历当前元素的下一层了，因为所有的可能结果在遍历前一个相等元素的时候，都找过了。</li></ul></li><li>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        if not candidates:</span><br><span class="line">            return []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        return self.helper(candidates, [], [], target)</span><br><span class="line">    </span><br><span class="line">    def helper(self, candidates, tmp, res, target):</span><br><span class="line">        if target &#x3D;&#x3D; 0:</span><br><span class="line">            res.append(copy.deepcopy(tmp))</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line">        for i in range(len(candidates)):</span><br><span class="line">            if i &gt; 0 and candidates[i] &#x3D;&#x3D; candidates[i - 1]:</span><br><span class="line">                continue</span><br><span class="line">            if candidates[i] &lt;&#x3D; target:</span><br><span class="line">                tmp.append(candidates[i])</span><br><span class="line">                self.helper(candidates[i+1:], tmp, res, target-candidates[i])</span><br><span class="line">                tmp.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anki2.1插件推荐</title>
      <link href="/2020/06/01/Anki%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/06/01/Anki%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="插件首页"><a href="#插件首页" class="headerlink" title="插件首页"></a>插件首页</h4><p><a href="https://ankiweb.net/shared/addons/2.1" target="_blank" rel="noopener">https://ankiweb.net/shared/addons/2.1</a></p><a id="more"></a><h4 id="插件1-ReviewHeatmap"><a href="#插件1-ReviewHeatmap" class="headerlink" title="插件1 ReviewHeatmap"></a>插件1 ReviewHeatmap</h4><p>下载地址：<a href="https://ankiweb.net/shared/info/723520343" target="_blank" rel="noopener">https://ankiweb.net/shared/info/723520343</a></p><p>插件代码：<code>723520343</code></p><p>展示：</p><p><a href="https://sm.ms/image/3saKlzvUqSm4nWM" target="_blank"><img src="https://i.loli.net/2020/06/01/3saKlzvUqSm4nWM.png" ></a></p><p>说明：</p><p>用颜色的深浅表示当天看了多少卡片，右上角的<a href="https://sm.ms/image/zfVOi4hNlQCRwWI" target="_blank"><img src="https://i.loli.net/2020/06/01/zfVOi4hNlQCRwWI.png" ></a>可以设置颜色和其他。</p><h4 id="插件2-AwesomeTTS-for-Anki-2-1"><a href="#插件2-AwesomeTTS-for-Anki-2-1" class="headerlink" title="插件2 AwesomeTTS for Anki 2.1"></a>插件2 AwesomeTTS for Anki 2.1</h4><p>下载地址：<a href="https://ankiweb.net/shared/info/814349176" target="_blank" rel="noopener">https://ankiweb.net/shared/info/814349176</a></p><p>插件代码：<code>814349176</code></p><p>展示：</p><p><a href="https://sm.ms/image/dVNBfrasg548Tw2" target="_blank"><img src="https://i.loli.net/2020/06/01/dVNBfrasg548Tw2.png" ></a></p><p><a href="https://sm.ms/image/pCU97jsxfHh2ImB" target="_blank"><img src="https://i.loli.net/2020/06/01/pCU97jsxfHh2ImB.png" ></a></p><p>说明：</p><p>可以插入单词读音。</p><h4 id="插件3-Large-and-Colorful-Buttons"><a href="#插件3-Large-and-Colorful-Buttons" class="headerlink" title="插件3 Large and Colorful Buttons"></a>插件3 Large and Colorful Buttons</h4><p>下载地址：<a href="https://ankiweb.net/shared/info/1829090218" target="_blank" rel="noopener">https://ankiweb.net/shared/info/1829090218</a></p><p>插件代码：<code>1829090218</code></p><p>展示：</p><p><a href="https://sm.ms/image/zkywZmdacTuSsX3" target="_blank"><img src="https://i.loli.net/2020/06/01/zkywZmdacTuSsX3.png" ></a></p><p><a href="https://sm.ms/image/g7C4cXdhqem63f8" target="_blank"><img src="https://i.loli.net/2020/06/01/g7C4cXdhqem63f8.png" ></a></p><p>说明：</p><p>比较大的按键。</p><h4 id="插件4-Colorful-toolbars"><a href="#插件4-Colorful-toolbars" class="headerlink" title="插件4 Colorful toolbars"></a>插件4 Colorful toolbars</h4><p>下载地址：<a href="https://ankiweb.net/shared/info/388296573" target="_blank" rel="noopener">https://ankiweb.net/shared/info/388296573</a></p><p>插件代码：<code>388296573</code></p><p>展示：</p><p><a href="https://sm.ms/image/qGRm8kcKh79lg3b" target="_blank"><img src="https://i.loli.net/2020/06/01/qGRm8kcKh79lg3b.png" ></a></p><p>说明：</p><p>把首页文字的按键变成了图标。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Github访问慢的方法</title>
      <link href="/2020/05/14/%E8%A7%A3%E5%86%B3Github%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/14/%E8%A7%A3%E5%86%B3Github%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1-使用浏览器访问https-www-ipaddress-com-。"><a href="#1-使用浏览器访问https-www-ipaddress-com-。" class="headerlink" title="1.使用浏览器访问https://www.ipaddress.com/。"></a>1.使用浏览器访问<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a>。</h5><p>在这个位置分别输入github.com和github.global.ssl.fastly.net<br><a href="https://sm.ms/image/iE9AqQkXPVe7Lud" target="_blank"><img src="https://i.loli.net/2020/05/23/iE9AqQkXPVe7Lud.png" ></a></p><a id="more"></a><p><a href="https://sm.ms/image/Zq9cnGJBEyl2gKF" target="_blank"><img src="https://i.loli.net/2020/05/23/Zq9cnGJBEyl2gKF.png" ></a><br>搜索一下~<br>找到github.com对应的ip：<br><a href="https://sm.ms/image/4WlHben3hzaARGq" target="_blank"><img src="https://i.loli.net/2020/05/23/4WlHben3hzaARGq.png" ></a></p><p>找到github.global.ssl.fastly.net对应的ip：<br><a href="https://sm.ms/image/oL7bgRMtOumI9fF" target="_blank"><img src="https://i.loli.net/2020/05/23/oL7bgRMtOumI9fF.png" ></a></p><p>每台电脑获取的ip应该不一样。<br>我获取的是<code>140.82.112.3</code>和<code>199.232.69.194</code>。</p><h5 id="2-Windows系统打开以下目录："><a href="#2-Windows系统打开以下目录：" class="headerlink" title="2.Windows系统打开以下目录："></a>2.Windows系统打开以下目录：</h5><p><code>C:\Windows\System32\drivers\etc</code><br>用记事本打开host文件，把以下内容添加进去：</p><blockquote><p>140.82.112.3   github.com<br>199.232.69.194 github.global.ssl.fastly.Net</p></blockquote><p><a href="https://sm.ms/image/gMLqcuQ6eVv8TlH" target="_blank"><img src="https://i.loli.net/2020/05/23/gMLqcuQ6eVv8TlH.png" ></a><br>保存、关闭。</p><h5 id="3-打开cmd"><a href="#3-打开cmd" class="headerlink" title="3.打开cmd"></a>3.打开cmd</h5><p>用windows+R打开：<br><a href="https://sm.ms/image/GimRw97Yl2Vbj5d" target="_blank"><img src="https://i.loli.net/2020/05/23/GimRw97Yl2Vbj5d.png" ></a><br>输入cmd，回车。<br>在小黑框里输入<code>ipconfig /flushdns</code>，更新DNS缓存。<br><a href="https://sm.ms/image/ezkd2uAmtfCRnGQ" target="_blank"><img src="https://i.loli.net/2020/05/23/ezkd2uAmtfCRnGQ.png" ></a></p><h5 id="4-再次访问Github"><a href="#4-再次访问Github" class="headerlink" title="4.再次访问Github"></a>4.再次访问Github</h5><p>快多啦！</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>置顶</title>
      <link href="/2020/05/09/%E7%BD%AE%E9%A1%B6/"/>
      <url>/2020/05/09/%E7%BD%AE%E9%A1%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>博客搬迁中。。。<br>源地址：<a href="https://www.jianshu.com/u/400aba58cff5" target="_blank" rel="noopener">https://www.jianshu.com/u/400aba58cff5</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符重载实现(加号、左移、递增、赋值、关系运算符、函数调用)</title>
      <link href="/2020/05/06/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0(%E5%8A%A0%E5%8F%B7%E3%80%81%E5%B7%A6%E7%A7%BB%E3%80%81%E9%80%92%E5%A2%9E%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8)/"/>
      <url>/2020/05/06/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0(%E5%8A%A0%E5%8F%B7%E3%80%81%E5%B7%A6%E7%A7%BB%E3%80%81%E9%80%92%E5%A2%9E%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先来复习一下C++的内存分区问题~</p><a id="more"></a><h2 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++内存分区"></a>C++内存分区</h2><p>C++程序的内存分区可划分为四大内存分区：堆、栈、全局/静态存储区和代码区。 不同类型的变量存放的区域不同。</p><p><strong>在程序被编译为exe可执行文件后，未运行之前，分为两个区域：代码区和全局区。</strong></p><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>存放程序体的二进制代码。比如我们写的函数，都是在代码区的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 0;&#x2F;&#x2F;静态全局变量区</span><br><span class="line">char *p1; &#x2F;&#x2F;编译器默认初始化为NULL</span><br><span class="line">void main()&#123;    </span><br><span class="line">        int b; &#x2F;&#x2F;栈    </span><br><span class="line">        char s[] &#x3D; &quot;abc&quot;;&#x2F;&#x2F;栈    </span><br><span class="line">        char *p2 &#x3D; &quot;123456&quot;;&#x2F;&#x2F;123456在字符串常量区，p2在栈上    </span><br><span class="line">        static int c &#x3D;0; &#x2F;&#x2F;c在静态变量区，0为文字常量，在代码区    </span><br><span class="line">        const int d&#x3D;0; &#x2F;&#x2F;栈    </span><br><span class="line">        static const int d;&#x2F;&#x2F;静态常量区    </span><br><span class="line">        p1 &#x3D; (char *)malloc(10);&#x2F;&#x2F;分配得来得10字节在堆区。    </span><br><span class="line">        strcpy(p1, &quot;123456&quot;); &#x2F;&#x2F;123456放在字符串常量区，编译器可能会将它与p2所指向的&quot;123456&quot;优化成一个地方</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>以上所有代码，编译成二进制后存放于代码区，文字常量存放于代码区，是不可寻址的。</p><h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><p>全局区存储<strong>全局变量</strong>，<strong>静态变量</strong>，还包括了<strong>常量区</strong>，字符串常量和其他常量（const修饰的<strong>全局变量</strong>）也存放在全局区。<br>全局区的数据在程序结束后由操作系统释放。</p><p><strong>程序运行之后</strong></p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>由编译器自动释放，存放函数的参数值，局部变量等。<br>整个程序的栈区的大小可以在编译器中由用户自行设定。</p><p>注意：不要返回局部变量地址。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。<br>使用new进行堆的申请，堆的总大小为机器的虚拟内存的大小。new返回的是该数据类型的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * p &#x3D; new int(10);</span><br></pre></td></tr></table></figure><p>使用delete进行释放。</p><h3 id="重载方式有两种："><a href="#重载方式有两种：" class="headerlink" title="重载方式有两种："></a>重载方式有两种：</h3><p><strong>1.重载的函数作为成员函数。<br>2.重载的函数作为全局函数</strong><br>函数名是规定的：operator+</p><h2 id="加号运算符（“-”）重载"><a href="#加号运算符（“-”）重载" class="headerlink" title="加号运算符（“+”）重载"></a>加号运算符（“+”）重载</h2><p>对于内置的数据类型，编译器知道如何进行运算。<br>两个自定义的数据类型，进行相加，就需要进行加号运算符重载。</p><p><strong>成员函数实现加号重载：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    Person operator+(Person &amp;p)&#123;</span><br><span class="line">        Person tmp;</span><br><span class="line">        tmp.a &#x3D; this-&gt;a + p.a;</span><br><span class="line">        tmp.b &#x3D; this-&gt;b + p.b;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person A;</span><br><span class="line">    A.a &#x3D; 10;</span><br><span class="line">    A.b &#x3D; 20;</span><br><span class="line">    </span><br><span class="line">    Person B;</span><br><span class="line">    B.a &#x3D; 1;</span><br><span class="line">    B.b &#x3D; 3;</span><br><span class="line">    </span><br><span class="line">    Person C;</span><br><span class="line">    C &#x3D; A + B;</span><br><span class="line">    cout &lt;&lt; C.a &lt;&lt; &quot;  &quot; &lt;&lt; C.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-62d12b2b2cb500c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>全局函数实现加号重载：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person operator+(Person &amp;p1,Person &amp;p2)&#123;    &#x2F;&#x2F;需要传入两个参数</span><br><span class="line">    Person tmp;</span><br><span class="line">    tmp.a &#x3D; p1.a + p2.a;</span><br><span class="line">    tmp.b &#x3D; p1.b + p2.b;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person A;</span><br><span class="line">    A.a &#x3D; 10;</span><br><span class="line">    A.b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    Person B;</span><br><span class="line">    B.a &#x3D; 1;</span><br><span class="line">    B.b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    Person C;</span><br><span class="line">    C &#x3D; A + B;</span><br><span class="line">    cout &lt;&lt; C.a &lt;&lt; &quot;  &quot; &lt;&lt; C.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-af5bd742104fdf19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>运算符重载也可以发生函数重载</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person operator+(Person &amp;p1,Person &amp;p2)&#123;</span><br><span class="line">    Person tmp;</span><br><span class="line">    tmp.a &#x3D; p1.a + p2.a;</span><br><span class="line">    tmp.b &#x3D; p1.b + p2.b;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person operator+(Person &amp;p1,int n)&#123;  &#x2F;&#x2F;函数重载</span><br><span class="line">    Person tmp;</span><br><span class="line">    tmp.a &#x3D; p1.a + n;</span><br><span class="line">    tmp.b &#x3D; p1.b + n;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person A;</span><br><span class="line">    A.a &#x3D; 10;</span><br><span class="line">    A.b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    Person B;</span><br><span class="line">    B.a &#x3D; 1;</span><br><span class="line">    B.b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    Person C;</span><br><span class="line">    C &#x3D; A + B;</span><br><span class="line">    cout &lt;&lt; C.a &lt;&lt; &quot;  &quot; &lt;&lt; C.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person D;</span><br><span class="line">    D &#x3D; A + 10;</span><br><span class="line">    cout &lt;&lt; D.a &lt;&lt; &quot;  &quot; &lt;&lt; D.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="https://upload-images.jianshu.io/upload_images/14394806-0127a16462d014dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="左移运算符（“-lt-lt-”）符重载"><a href="#左移运算符（“-lt-lt-”）符重载" class="headerlink" title="左移运算符（“&lt;&lt;”）符重载"></a>左移运算符（“&lt;&lt;”）符重载</h2><p>可以输出自定义的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout , Person &amp;p)&#123;</span><br><span class="line">    cout &lt;&lt; p.a &lt;&lt; &quot;   &quot; &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">    return cout;   &#x2F;&#x2F;返回cout 可以实现链式编程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person A;</span><br><span class="line">    A.a &#x3D; 10;</span><br><span class="line">    A.b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-4628490bad8f3ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>左移运算符重载无法用成员函数来实现</strong><br>因为要实现的是<code>cout &lt;&lt; A &lt;&lt; endl;</code>看例子吧~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line"></span><br><span class="line">    ostream&amp; operator&lt;&lt;(ostream &amp;cout)&#123;</span><br><span class="line">        cout &lt;&lt; this-&gt;a &lt;&lt; &quot;   &quot; &lt;&lt; this-&gt;b &lt;&lt; endl;</span><br><span class="line">        return cout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person A;</span><br><span class="line">    A.a &#x3D; 10;</span><br><span class="line">    A.b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    A &lt;&lt; cout &lt;&lt; endl; &#x2F;&#x2F;如果用成员函数，最后实现了是这样的。。。(因为是A调用，所以A写在前)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-303c955528a2b9b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="递增运算符（“-”）重载"><a href="#递增运算符（“-”）重载" class="headerlink" title="递增运算符（“++”）重载"></a>递增运算符（“++”）重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    Person&amp; operator++()&#123;   &#x2F;&#x2F;前置递增返回的是引用，这样++(++A)也不会出错</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;后置递增返回的是值</span><br><span class="line">    Person operator++(int)&#123;    &#x2F;&#x2F;int是占位参数，可以用来区分前置和后置，必须写int，其他类型不可以</span><br><span class="line">        Person tmp &#x3D; *this;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout , Person &amp;p)&#123;</span><br><span class="line">    cout &lt;&lt; p.a &lt;&lt; &quot;   &quot; &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person A;</span><br><span class="line">    A.a &#x3D; 10;</span><br><span class="line">    A.b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;原始A的值：&quot; &lt;&lt;A &lt;&lt; endl;</span><br><span class="line">    ++A;</span><br><span class="line">    cout &lt;&lt; &quot;A++后的值：&quot; &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">    A++;</span><br><span class="line">    cout &lt;&lt; &quot;A++后的值：&quot; &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-3aea18e121949e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="赋值运算符（“-”）重载"><a href="#赋值运算符（“-”）重载" class="headerlink" title="赋值运算符（“=”）重载"></a>赋值运算符（“=”）重载</h2><p>存在复制运算符的原因是<strong>堆区的数据重复释放，也就是浅拷贝的问题。</strong><br>详细解释：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-f8b7fcff439906dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在对象P1中new一个age变量，这个遍历被存储在堆区，需要程序员手动申请，手动释放，把P1赋给p2时，P2也指向这个堆区的地址空间，所以当使用析构函数对堆区数据进行释放时，P1释放了一次，P2又释放了一次，出现了堆区数据重复释放的情况，程序崩溃。</p><p>解决方案：<br>利用深拷贝来解决浅拷贝的问题。<br>因为出现程序崩溃的主要原因是，当p2 = p1时，p2直接指向了0x0011这块地址，使用赋值运算符重载，使p2 = p1时，p2开辟一个新的地址空间用来存储年龄18这个数据，这样在释放时，就不会重复释放了。<br><img src="https://upload-images.jianshu.io/upload_images/14394806-93ebad4d9de212b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(int age) &#123;</span><br><span class="line">        this-&gt;age &#x3D; new int(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int *age;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        if (age !&#x3D; NULL) &#123;</span><br><span class="line">            delete age;</span><br><span class="line">            age &#x3D; NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person &amp;operator&#x3D;(Person &amp;p) &#123;  &#x2F;&#x2F;返回类型是Person，可以链式赋值，p3 &#x3D; p2 &#x3D; p1</span><br><span class="line">        if (this-&gt;age !&#x3D; NULL) &#123;</span><br><span class="line">            delete age;</span><br><span class="line">            age &#x3D; NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        age &#x3D; new int(*p.age);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person p1(10);</span><br><span class="line">    cout &lt;&lt; *p1.age &lt;&lt; endl;  &#x2F;&#x2F;p1.age是指针</span><br><span class="line"></span><br><span class="line">    Person p2(18);</span><br><span class="line">    cout &lt;&lt; *p2.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p2 &#x3D; p1;</span><br><span class="line">    cout &lt;&lt; *p2.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p3(20);</span><br><span class="line">    cout &lt;&lt; *p3.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p1 &#x3D; p2 &#x3D; p3;</span><br><span class="line">    cout &lt;&lt; *p1.age &lt;&lt; &quot;  &quot; &lt;&lt; *p2.age &lt;&lt; &quot;  &quot; &lt;&lt; *p3.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-bd63316cce09ae8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    Person(string name, int age,int sex) &#123;</span><br><span class="line">        this-&gt;name &#x3D; name;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">        this-&gt;sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">    int sex;</span><br><span class="line"></span><br><span class="line">    bool operator&#x3D;&#x3D;(Person &amp;p)&#123;</span><br><span class="line">        return this-&gt;name &#x3D;&#x3D; p.name &amp;&amp; this-&gt;age &#x3D;&#x3D; p.age &amp;&amp; this-&gt;sex &#x3D;&#x3D; p.sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator!&#x3D;(Person &amp;p)&#123;</span><br><span class="line">        return !(this-&gt;name &#x3D;&#x3D; p.name &amp;&amp; this-&gt;age &#x3D;&#x3D; p.age &amp;&amp; this-&gt;sex &#x3D;&#x3D; p.sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person p1(&quot;Tom&quot;,23,1);</span><br><span class="line">    Person p2(&quot;Tom&quot;,23,1);</span><br><span class="line">    Person p3(&quot;Amy&quot;,23,2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (p1 &#x3D;&#x3D; p2 ? &quot;相等&quot; : &quot;不相等&quot;)&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (p2 &#x3D;&#x3D; p3 ? &quot;相等&quot; : &quot;不相等&quot;)&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (p1 !&#x3D; p2 ? &quot;不相等&quot; : &quot;相等&quot;)&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (p2 !&#x3D; p3 ? &quot;不相等&quot; : &quot;相等&quot;)&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-a610813d8ad667ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void operator()(int b) &#123;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.operator()(6);</span><br><span class="line">    &#x2F;&#x2F; 匿名函数对象</span><br><span class="line">    Person()(9);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-be5f7f656a9ae3ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="noopener">菜鸟教程的C++ 重载运算符和重载函数</a></p><p>补充：<br><img src="https://upload-images.jianshu.io/upload_images/14394806-175cac10f0f9b23a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现排序及时间空间复杂度分析</title>
      <link href="/2020/03/11/Python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/11/Python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文链接：<a href="https://www.jianshu.com/p/e398e4c3bb05" target="_blank" rel="noopener">https://www.jianshu.com/p/e398e4c3bb05</a></p><h3 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a>一、冒泡排序（Bubble Sort）</h3><p><strong>原理：</strong></p><blockquote><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。（从头到尾，从尾到头都可以）</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol></blockquote><a id="more"></a><p><strong>动画：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14394806-aa55d641f1b54cae.gif?imageMogr2/auto-orient/strip" alt="冒泡排序.gif"></p><p><strong>图片说明第一次排序：</strong><br><a href="https://sm.ms/image/IAqEgzh2QuLlFDi" target="_blank"><img src="https://i.loli.net/2020/05/13/IAqEgzh2QuLlFDi.png" ></a><br><strong>图片说明所有排序：</strong><br><a href="https://sm.ms/image/JN4Emb9UAcu8wfe" target="_blank"><img src="https://i.loli.net/2020/05/13/JN4Emb9UAcu8wfe.png" ></a></p><p><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def BubbleSort(matrix):</span><br><span class="line">    for i in range(len(matrix) - 1):</span><br><span class="line">        for j in range(len(matrix)-i-1):#要用到j+1，防止溢出，减掉1</span><br><span class="line">            if matrix[j] &gt; matrix[j + 1]:</span><br><span class="line">                matrix[j], matrix[j + 1] &#x3D; matrix[j + 1], matrix[j]</span><br><span class="line">    return matrixB</span><br></pre></td></tr></table></figure><p>从左到右找到依次找到较大的元素，如果左边的元素比右边的元素大，交换这两个元素。一共循环了len（matrix）-1次。</p><p><strong>优化:</strong><br>如果一个已经排好的数组，用这个算法还是要比较很多次。<br>所以增加一个flag，赋值为True，在一次循环中，如果没有两个元素进行交换，说明数组是已经排好序的，在当前循环结束时，flag的值没有发生改变依旧为True，可直接break出循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def BubbleSort(matrix):</span><br><span class="line">    flag &#x3D; True</span><br><span class="line">    for i in range(len(matrix) - 1):</span><br><span class="line">        for j in range(len(matrix) - i - 1):</span><br><span class="line">            if matrix[j] &gt; matrix[j + 1]:</span><br><span class="line">                matrix[j], matrix[j + 1] &#x3D; matrix[j + 1], matrix[j]</span><br><span class="line">                flag &#x3D; False</span><br><span class="line">        if (flag): break</span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong><br>外层的for时间复杂度为O（n）<br>里层的时间复杂度分析如下：<br>因为里层的起点是0，结束是len（matrix）-i-1，（以下用n代替len（matrix））当i == 0 时，里层循环是n-1次，i == 1时，循环为n-1次，当i == n-1时，需要0次。把i为（0，n-1）时所有的循环次数加起来就是从0加到n-1，值为首项加尾项乘以项数除以二，即（0+n-1）n/2，这个的时间复杂度我O（n）。所有里层的循环时间复杂度为O（n）。<br>所以时间复杂度为O（n^2）</p><p>最差情况是需要交换n^2次，最好情况是不需要交换。</p><p><strong>空间复杂度：</strong><br>不需要额外的空间。所以O（1）</p><p><strong>稳定性：</strong><br>冒泡排序是一个稳定的排序方式，比如matrix = [25, 25, 3, 9, 23, 44, 29]时，出现了两个25，在冒泡排序结束后，从左边数的第一个25，在排序结束时，依旧是从左数的第一个25，它不会出现在第二个25的右面。（因为在元素相等的时候没有进行交换）</p><h3 id="二、选择排序（Selction-Sort）"><a href="#二、选择排序（Selction-Sort）" class="headerlink" title="二、选择排序（Selction Sort）"></a>二、选择排序（Selction Sort）</h3><p><strong>原理：</strong><br>第一次循环找出最大值（最小值），记录其下标，把他与最末尾（首）的元素交换，第二次找到第二大的，与倒数第二末尾的元素进行交换。第一次循环的范围是（0，数组长度-1），第二次是（0，数组长度-2）<br><strong>动画：</strong><br><a href="https://sm.ms/image/yeRKXDvaJmu9VAg" target="_blank"><img src="https://i.loli.net/2020/05/13/yeRKXDvaJmu9VAg.gif" ></a><br><strong>图片说明：</strong><br><a href="https://sm.ms/image/CGUhsI9xzw5tr8a" target="_blank"><img src="https://i.loli.net/2020/05/13/CGUhsI9xzw5tr8a.png" ></a><br><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def SelectionSort(matrix):</span><br><span class="line">    n &#x3D; len(matrix)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        for j in range(n - i):</span><br><span class="line">            if matrix[j] &gt; matrix[index]:</span><br><span class="line">                index &#x3D; j</span><br><span class="line">        matrix[n - i - 1], matrix[index] &#x3D; matrix[index], matrix[n - i - 1]</span><br><span class="line"></span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong><br>两次for循环：O（n^2），进行了O（n）次交换。</p><p><strong>空间复杂度：</strong><br>不需要额外的空间。所以O（1）</p><p><strong>稳定性：</strong><br>不稳定。</p><h3 id="三、插入排序（Insert-Sort）"><a href="#三、插入排序（Insert-Sort）" class="headerlink" title="三、插入排序（Insert Sort）"></a>三、插入排序（Insert Sort）</h3><p><strong>原理：</strong><br>相当于打牌时候摸牌，如数组[25, 5, 3, 9, 23, 44, 29]，第一张摸到的牌是25，第二张摸到了5，与25比较大小，放在25前面，依次摸完所有的牌，也就排序结束了。<br><strong>动画：</strong><br><img src="https://upload-images.jianshu.io/upload_images/14394806-a3b44d750da1da31.gif?imageMogr2/auto-orient/strip" alt="插入排序.gif"><br><strong>图片说明：</strong><br><a href="https://sm.ms/image/wyZOnIkQp7KM5Hi" target="_blank"><img src="https://i.loli.net/2020/05/13/wyZOnIkQp7KM5Hi.png" ></a><br><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def InsertSort(matrix):</span><br><span class="line">    n &#x3D; len(matrix)</span><br><span class="line">    for i in range(1, n):</span><br><span class="line">        cur &#x3D; i</span><br><span class="line">        pre &#x3D; cur - 1</span><br><span class="line">        while pre &gt;&#x3D; 0 and matrix[cur] &lt; matrix[pre]:</span><br><span class="line">            if matrix[cur] &lt; matrix[pre]:</span><br><span class="line">                matrix[pre], matrix[cur] &#x3D; matrix[cur], matrix[pre]</span><br><span class="line">                cur &#x3D; pre</span><br><span class="line">                pre &#x3D; cur - 1</span><br><span class="line"></span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p>定义一个cur来存储当前的下标，因为pre是cir-1，所以循环从1开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def InsertSort(matrix):</span><br><span class="line">    n &#x3D; len(matrix)</span><br><span class="line">    for i in range(1, n):</span><br><span class="line">        cur &#x3D; i</span><br><span class="line">        while cur - 1 &gt;&#x3D; 0 and matrix[cur] &lt; matrix[cur - 1]:</span><br><span class="line">            if matrix[cur] &lt; matrix[cur - 1]:</span><br><span class="line">                matrix[cur - 1], matrix[cur] &#x3D; matrix[cur], matrix[cur - 1]</span><br><span class="line">                cur -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p>把pre用cur-1代替了。</p><p>也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def InsertSort(matrix):</span><br><span class="line">    for i in range(1, len(matrix)):</span><br><span class="line">        tmp &#x3D; i</span><br><span class="line">        while i &gt; 0:</span><br><span class="line">            if matrix[i] &lt; matrix[i - 1]:</span><br><span class="line">                matrix[i], matrix[i - 1] &#x3D; matrix[i - 1], matrix[i]</span><br><span class="line">                i -&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong><br>两个嵌套的循环，时间复杂度是O(n^2)。<br>虽然时间复杂度也是O(n^2)，但是第二层循环不需要与所有元素进行比较，所以在性能上优于冒泡排序和选择排序。<br><strong>空间复杂度：</strong><br>没有额外的存储空间，是原地排序算法O（1）。<br><strong>稳定性：</strong><br>稳定</p><h3 id="四、希尔排序（Shell-Sort）"><a href="#四、希尔排序（Shell-Sort）" class="headerlink" title="四、希尔排序（Shell Sort）"></a>四、希尔排序（Shell Sort）</h3><p><strong>原理：</strong><br>实际上是插入排序的扩展，把数组分成几组，比如数组[25, 5, 3, 9, 23, 44, 29]，数组长度n为7，取gap = n/2，把数组的[i]和[i+gap]作为一组，比较[i]和[i+gap]的大小，如果[i]&gt;[i+gap]，交换[i]和[i+gap]，如果[i]&lt;[i+gap]，则继续比较[i+1]和[i+gap+1]，把数组里的所有元素都比较完之后，再把gap的值减小，可以减1，也可以把gap/2，继续比较，直至最后一次把数组中的所有元素作为一个整体排序。<br><strong>动画：</strong><br><a href="https://sm.ms/image/6SuXYNJ4EMG1Ir8" target="_blank"><img src="https://i.loli.net/2020/05/13/6SuXYNJ4EMG1Ir8.gif" ></a><br><strong>图片说明：</strong><br><a href="https://sm.ms/image/rqgaeJCc8LsX7Ux" target="_blank"><img src="https://i.loli.net/2020/05/13/rqgaeJCc8LsX7Ux.png" ></a><br><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def ShellSort(matrix):</span><br><span class="line">    n &#x3D; len(matrix)</span><br><span class="line">    gap &#x3D; n &#x2F;&#x2F; 2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        for i in range(gap, n):</span><br><span class="line">            for tmp in range(i, gap - 1, -gap):</span><br><span class="line">                if matrix[tmp] &lt; matrix[tmp - gap]:</span><br><span class="line">                    matrix[tmp], matrix[tmp - gap] &#x3D; matrix[tmp - gap], matrix[tmp]</span><br><span class="line"></span><br><span class="line">        if gap &#x3D;&#x3D; 2:</span><br><span class="line">            gap &#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            gap &#x2F;&#x2F;&#x3D; 2</span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><h3 id="五、计数排序（Count-Sort）"><a href="#五、计数排序（Count-Sort）" class="headerlink" title="五、计数排序（Count Sort）"></a>五、计数排序（Count Sort）</h3><p><strong>使用范围：</strong><br>数组长度有限，较小。<br>出现的重复数字比较多，并且这些数值较为集中。<br><strong>原理：</strong><br>抽屉原理：遍历数组，把相同的值都放到同一个抽屉中，遍历结束后，按照值从小到大的顺序依次取出，即排列完成。<br><strong>动画：</strong><br><a href="https://sm.ms/image/Wb56MzNnDymO47p" target="_blank"><img src="https://i.loli.net/2020/05/13/Wb56MzNnDymO47p.gif" ></a></p><p><strong>图片说明：</strong><br><a href="https://sm.ms/image/Vkb5gqyeEi1XIpU" target="_blank"><img src="https://i.loli.net/2020/05/13/Vkb5gqyeEi1XIpU.png" ></a></p><p><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def CountSort(matrix):</span><br><span class="line">    max &#x3D; matrix[0]</span><br><span class="line">    min &#x3D; matrix[0]</span><br><span class="line">    for i in matrix:  #找到list中的最大元素和最小元素</span><br><span class="line">        if i &gt; max:</span><br><span class="line">            max &#x3D; i</span><br><span class="line">        if i &lt; min:</span><br><span class="line">            min &#x3D; i</span><br><span class="line"></span><br><span class="line">    tmp &#x3D; [0] * (max - min + 1) # 定义一个新的数组，长度为最大值减最小值加一</span><br><span class="line">    for i in range(len(matrix)):  #把原来数组中每个数字出现了多少次存在新数组中</span><br><span class="line">        tmp[matrix[i] - min] +&#x3D; 1</span><br><span class="line">    index &#x3D; 0</span><br><span class="line"></span><br><span class="line">    for j in range(len(tmp)):    # </span><br><span class="line">        while tmp[j] &gt; 0:</span><br><span class="line">            matrix[index] &#x3D; min + j</span><br><span class="line">            index +&#x3D; 1</span><br><span class="line">            tmp[j] -&#x3D; 1</span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong><br>第一个循环：O（n）<br>第二个循<br>环：O（n）<br>第三个循环：O（n），虽然有两个for但是实际上是从头到尾把元素都拿出来，只走了一遍所以时间复杂度还是O（n）<br>所以时间复杂度为O（n）<br><strong>稳定性：</strong><br>不稳定</p><h3 id="六、归并排序（Merge-Sort）"><a href="#六、归并排序（Merge-Sort）" class="headerlink" title="六、归并排序（Merge Sort）"></a>六、归并排序（Merge Sort）</h3><p><strong>原理：</strong><br>把数组从中间分成前后两个数组，再把前后两个数组每个数组再分，分到最小，然后对前后两部分分别排序，再将排好序的两部分合并在一起。</p><p><strong>图片说明：</strong><br><a href="https://sm.ms/image/RkuSIL2mG56sljg" target="_blank"><img src="https://i.loli.net/2020/05/13/RkuSIL2mG56sljg.png" ></a><br><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def MergeSort(matrix):</span><br><span class="line">    matrix &#x3D; devide(matrix)</span><br><span class="line">    return matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def devide(matrix):</span><br><span class="line">    if len(matrix) &lt;&#x3D; 1:</span><br><span class="line">        return matrix</span><br><span class="line"></span><br><span class="line">    m &#x3D; len(matrix) &#x2F;&#x2F; 2</span><br><span class="line">    a &#x3D; devide(matrix[:m])</span><br><span class="line">    b &#x3D; devide(matrix[m:])</span><br><span class="line">    return merge(a, b)</span><br><span class="line"></span><br><span class="line">def merge(num1,num2):</span><br><span class="line">    num &#x3D; []</span><br><span class="line"></span><br><span class="line">    while len(num1) &gt; 0 and len(num2) &gt; 0:</span><br><span class="line">        if num1[0] &gt; num2[0]:</span><br><span class="line">            num.append(num2[0])</span><br><span class="line">            num2.remove(num2[0])</span><br><span class="line">        else:</span><br><span class="line">            num.append(num1[0])</span><br><span class="line">            num1.remove(num1[0])</span><br><span class="line">    if len(num1) &#x3D;&#x3D; 0:</span><br><span class="line">        num +&#x3D; num2</span><br><span class="line">    else:</span><br><span class="line">        num +&#x3D; num1</span><br><span class="line">    return num</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong><br>时间复杂度是 O(nlogn)，要优于 O(n^2)。<br><strong>空间复杂度：</strong><br>空间复杂度是 O(n)。<br><strong>稳定性：</strong><br>稳定</p><h3 id="七、快速排序（Quick-Sort）"><a href="#七、快速排序（Quick-Sort）" class="headerlink" title="七、快速排序（Quick Sort）"></a>七、快速排序（Quick Sort）</h3><p><strong>原理：</strong><br>数组的一个元素赋给下标赋给first，末尾下标赋给last，把数组从左到右第一个元素的值赋给pivot，从数组末尾往前找到第一个比pivot值小的数，赋给matrix[first]，再从first往后找到第一个比pivot大的值，当first与last相遇时，把pivot的值赋给matrix[first]或matrix[last]，然后递归。</p><p><strong>Python实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def QuickSort(matrix, i, j):</span><br><span class="line">    if i &gt;&#x3D; j or i &lt; 0 or j &gt; len(matrix)-1:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        first &#x3D; i</span><br><span class="line">        last &#x3D; j</span><br><span class="line">        pivot &#x3D; matrix[i]</span><br><span class="line">        while first &lt; last:</span><br><span class="line">            while first &lt; last and matrix[last] &gt; pivot:</span><br><span class="line">                last -&#x3D; 1</span><br><span class="line"></span><br><span class="line">            matrix[i] &#x3D; matrix[last]</span><br><span class="line">            while first &lt; last and matrix[first] &lt; pivot:</span><br><span class="line">                first +&#x3D; 1</span><br><span class="line">            matrix[last] &#x3D; matrix[first]</span><br><span class="line"></span><br><span class="line">        matrix[first]&#x3D; pivot</span><br><span class="line"></span><br><span class="line">        QuickSort(matrix, i, first - 1)</span><br><span class="line">        QuickSort(matrix, first + 1, j)</span><br><span class="line">    return matrix</span><br></pre></td></tr></table></figure><p>快排参考链接：<br><a href="https://blog.csdn.net/u010005281/article/details/80084994" target="_blank" rel="noopener">https://blog.csdn.net/u010005281/article/details/80084994</a></p><p>文章参考：<br><a href="https://www.eet-china.com/mp/a11342.html" target="_blank" rel="noopener">硬核！C语言八大排序算法，附动图和详细代码解释！</a><br><a href="https://cloud.tencent.com/developer/article/1447538" target="_blank" rel="noopener">这或许是东半球分析十大排序算法最好的一篇文章</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a><br><a href="http://blog.jialongfei.com/article/61" target="_blank" rel="noopener">数据结构与算法系列（五）基于选择的排序算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
