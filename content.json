{"meta":{"title":"Arianna_blog","subtitle":"Arianna的博客","description":"Welcome to my blog!","author":"Arianna Wstson","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-05-12T03:09:15.293Z","updated":"2020-05-10T12:36:16.916Z","comments":true,"path":"Django-Web/index.html","permalink":"http://yoursite.com/Django-Web/index.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"","date":"2020-05-12T07:10:58.059Z","updated":"2020-05-12T07:10:58.059Z","comments":true,"path":"C/index.html","permalink":"http://yoursite.com/C/index.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"Django_Web","date":"2020-05-10T12:34:21.000Z","updated":"2020-05-10T13:05:46.191Z","comments":true,"path":"Django-Web/index.html","permalink":"http://yoursite.com/Django-Web/index.html","excerpt":"","text":""},{"title":"C++","date":"2020-05-12T07:02:23.000Z","updated":"2020-05-12T07:02:23.995Z","comments":true,"path":"C/index.html","permalink":"http://yoursite.com/C/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-12T07:10:58.174Z","updated":"2020-05-12T07:10:58.174Z","comments":true,"path":"Hexo/index.html","permalink":"http://yoursite.com/Hexo/index.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"","date":"2020-05-09T13:15:01.225Z","updated":"2020-05-09T13:15:01.225Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"categories","date":"2020-05-10T12:18:22.000Z","updated":"2020-05-10T13:05:45.935Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-11T01:02:05.306Z","updated":"2020-05-11T01:02:05.306Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"C++"},{"title":"MySQL","date":"2020-05-13T02:11:24.000Z","updated":"2020-05-13T02:11:24.668Z","comments":true,"path":"MySQL/index.html","permalink":"http://yoursite.com/MySQL/index.html","excerpt":"","text":""},{"title":"Hexo","date":"2020-05-11T01:17:57.000Z","updated":"2020-05-11T01:17:57.046Z","comments":true,"path":"Hexo/index.html","permalink":"http://yoursite.com/Hexo/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-13T02:26:08.948Z","updated":"2020-05-13T02:26:08.948Z","comments":true,"path":"MySQL/MySQL.html","permalink":"http://yoursite.com/MySQL/MySQL.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"","date":"2020-05-14T01:12:35.100Z","updated":"2020-05-14T01:12:35.100Z","comments":true,"path":"Github/index.html","permalink":"http://yoursite.com/Github/index.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"Github","date":"2020-05-14T01:04:26.000Z","updated":"2020-05-14T01:04:26.343Z","comments":true,"path":"Github/index.html","permalink":"http://yoursite.com/Github/index.html","excerpt":"","text":""},{"title":"blogs","date":"2020-05-10T13:07:06.000Z","updated":"2020-05-10T13:07:06.950Z","comments":true,"path":"blogs/index.html","permalink":"http://yoursite.com/blogs/index.html","excerpt":"","text":""},{"title":"Others","date":"2020-06-01T09:03:02.000Z","updated":"2020-06-01T09:03:02.513Z","comments":true,"path":"Others/index.html","permalink":"http://yoursite.com/Others/index.html","excerpt":"","text":""},{"title":"Algorithm","date":"2020-08-06T02:29:56.000Z","updated":"2020-08-06T02:29:56.879Z","comments":true,"path":"Algorithm/index.html","permalink":"http://yoursite.com/Algorithm/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-06T02:30:50.301Z","updated":"2020-05-12T07:10:58.058Z","comments":true,"path":"Algorithm/index.html","permalink":"http://yoursite.com/Algorithm/index.html","excerpt":"","text":"Title L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":200,\"height\":400},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7}});"},{"title":"data-structure","date":"2020-08-11T03:50:05.000Z","updated":"2020-08-11T03:50:05.609Z","comments":true,"path":"data-structure/index.html","permalink":"http://yoursite.com/data-structure/index.html","excerpt":"","text":""},{"title":"Python","date":"2020-08-11T03:56:58.000Z","updated":"2020-08-11T03:56:58.460Z","comments":true,"path":"Python/index.html","permalink":"http://yoursite.com/Python/index.html","excerpt":"","text":""}],"posts":[{"title":"Python的内存管理及垃圾回收机制","slug":"Python的内存管理及垃圾回收机制","date":"2020-08-14T01:42:15.000Z","updated":"2020-08-15T11:11:41.811Z","comments":true,"path":"2020/08/14/Python的内存管理及垃圾回收机制/","link":"","permalink":"http://yoursite.com/2020/08/14/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"首先要记住一句话： “Python采用的是引用计数机制为主，标记清除和分代回收两种机制为辅的策略。”","text":"首先要记住一句话： “Python采用的是引用计数机制为主，标记清除和分代回收两种机制为辅的策略。” 引用计数器首先来了解一下引用计数器，因为是以引用计数器为主的机制。 1.环状双向链表在Python中，有一个环状的双向链表叫refchain，任何对象都会被放在这个环状双向链表中。 123name &#x3D; &quot;cat&quot;age &#x3D; 10hobby &#x3D; [&quot;eat fish&quot;, &quot;sleep&quot;] 上面的代码一执行，会创建三个对象，一个字符串对象，一个整型对象，一个列表对象，这三个对象都会被放到这个链表中。 当python代码遇到name = &quot;cat&quot;，内部会创建一些数据（C语言源码是创建了一个结构体）：上一个对象，下一个对象，类型，引用的个数等等，当前对象的类型是字符串，引用的个数是1，因为name这个变量名引用了当前这个对象，如果new = name，那么这个引用计数会加一。 如果这个对象是由多个元素组成的，还会有一个值记录它的元素个数。 C的源码： 123456789101112131415#define PyObject_HEAD PyObject ob_base;#define PyObject_VAR_HEAD PyVarObject ob_base;&#x2F;&#x2F; 宏定义，包含 上一个、下一个，用于构造双向链表用。(放到refchain链表中时，要用到)#define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev;typedef struct _object &#123; _PyObject_HEAD_EXTRA &#x2F;&#x2F; 用于构造双向链表 Py_ssize_t ob_refcnt; &#x2F;&#x2F; 引用计数器 struct _typeobject *ob_type; &#x2F;&#x2F; 数据类型&#125; PyObject;typedef struct &#123; PyObject ob_base; &#x2F;&#x2F; PyObject对象 Py_ssize_t ob_size; &#x2F;* Number of items in variable part，即：元素个数 *&#x2F;&#125; PyVarObject; 如果是不同类型的数据，内部会创建以下的内容： float类型1234typedef struct &#123; PyObject_HEAD double ob_fval;&#125; PyFloatObject; int类型123456struct _longobject &#123; PyObject_VAR_HEAD digit ob_digit[1];&#125;;&#x2F;* Long (arbitrary precision) integer object interface *&#x2F;typedef struct _longobject PyLongObject; &#x2F;* Revealed in longintrepr.h *&#x2F; str类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950typedef struct &#123; PyObject_HEAD Py_ssize_t length; &#x2F;* Number of code points in the string *&#x2F; Py_hash_t hash; &#x2F;* Hash value; -1 if not set *&#x2F; struct &#123; unsigned int interned:2; &#x2F;* Character size: - PyUnicode_WCHAR_KIND (0): * character type &#x3D; wchar_t (16 or 32 bits, depending on the platform) - PyUnicode_1BYTE_KIND (1): * character type &#x3D; Py_UCS1 (8 bits, unsigned) * all characters are in the range U+0000-U+00FF (latin1) * if ascii is set, all characters are in the range U+0000-U+007F (ASCII), otherwise at least one character is in the range U+0080-U+00FF - PyUnicode_2BYTE_KIND (2): * character type &#x3D; Py_UCS2 (16 bits, unsigned) * all characters are in the range U+0000-U+FFFF (BMP) * at least one character is in the range U+0100-U+FFFF - PyUnicode_4BYTE_KIND (4): * character type &#x3D; Py_UCS4 (32 bits, unsigned) * all characters are in the range U+0000-U+10FFFF * at least one character is in the range U+10000-U+10FFFF *&#x2F; unsigned int kind:3; unsigned int compact:1; unsigned int ascii:1; unsigned int ready:1; unsigned int :24; &#125; state; wchar_t *wstr; &#x2F;* wchar_t representation (null-terminated) *&#x2F;&#125; PyASCIIObject;typedef struct &#123; PyASCIIObject _base; Py_ssize_t utf8_length; &#x2F;* Number of bytes in utf8, excluding the * terminating \\0. *&#x2F; char *utf8; &#x2F;* UTF-8 representation (null-terminated) *&#x2F; Py_ssize_t wstr_length; &#x2F;* Number of code points in wstr, possible * surrogates count as two code points. *&#x2F;&#125; PyCompactUnicodeObject;typedef struct &#123; PyCompactUnicodeObject _base; union &#123; void *any; Py_UCS1 *latin1; Py_UCS2 *ucs2; Py_UCS4 *ucs4; &#125; data; &#x2F;* Canonical, smallest-form Unicode buffer *&#x2F;&#125; PyUnicodeObject; list类型12345typedef struct &#123; PyObject_VAR_HEAD PyObject **ob_item; Py_ssize_t allocated;&#125; PyListObject; tuple类型1234typedef struct &#123; PyObject_VAR_HEAD PyObject *ob_item[1];&#125; PyTupleObject; dict类型123456typedef struct &#123; PyObject_HEAD Py_ssize_t ma_used; PyDictKeysObject *ma_keys; PyObject **ma_values;&#125; PyDictObject; 其中： _ob_next ： refchain中的上一个对象 _ob_prev：refchain中的下一个对象 ob_refnt：引用计数器 ob_type：是当前对象的类型 ob_fval：是这个对象的值 当python运行程序时，会根据数据类型的不同找到它对应的结构体，根据结构体中的字段来进行创建相关数据，然后将这个对象添加到refchain中。 大体机制：每个对象中有ob_refcnt就是引用计数器，默认值为1，当有其他变量引用对象时，引用计数器的值会增加，如果引用这个对象的变量被删除或者引用别的对象了，那么这个引用计数器的值会减小，当引用计数器的值变为0时，意味着没有变量在使用这个对象了，那么这个对象就变成了需要被删除的垃圾，系统就会将这个对象从refchian里面移除，将对象销毁，把这块内存还给系统。 2.单纯使用引用计数器进行垃圾回收的问题：循环引用如果是这样的一个代码： 12345678# refchian中创建一个列表对象，因为v1&#x3D;对象，所以对象的引用计数器为1v1 &#x3D; [11,22,33]# 同理为1v2 &#x3D; [44,55,66]# 把v2追加到v1中，那么[11,22,33]的引用计数器就会加一，变为2v1.append(v2)# 同理为2v2.append(v1) 这时候，如果删除了变量v1和变量v2： 1234# [11,22,33] 的引用计数器减一，变为1del v1# [44,55,66]同理为1del v2 这时候就会有一个问题，就是已经没有变量引用对象[11,22,33]和[44,55,66]了，但是因为他们的引用计数器不为0，这两个对象的内存空间没有被回收，所以他们会永远在内存中，而又永远不会被使用到。 所以为了解决这个问题，就有了标记清除。 标记清除标记清除就是为了解决引用计数器循环引用的问题。 实现方法就是在Python的底层再去维护一个环形双向链表，这个链表用来存放可能存在循环引用问题的对象。（只有对象可以再放其他元素的对象才会出现循环引用问题，列表，字典，元组和集合） 在Python内部，在某种情况下，回去扫描这个存放可能存在循环引用问题的对象的链表，如果发现有循环引用，就把双方的引用计数器都减一，如果引用计数器减为0，回收内存。 但是标记清除也存在问题： 什么时候会扫描一次 扫描一次存在耗时久的问题 所以又引入了分代回收。 分代回收实现方式就是把标记清除的那个链表分成了三个链表，这三个链表分别是：0代，1代，2代。 当0代中的对象个数超过700个，扫描一次0代。 0代如果扫描10次，则1代扫描一次。 1代扫描10次，2代扫描一次。 三个链表的阈值是不同的，0代是对象个数，1代和2代都是前一代的扫描次数。 总结在Python中维护了一个叫refchain的双向环状链表，这个链表用来存储程序创建的所有对象，每种类型的对象都有一个ob_refcnt引用计数器的值，当有变量引用对象时，引用计数器的值就会加一，当引用对象的变量减少了的时候，引用计数器的值就会减一，当引用计数器变为0时，就会进行垃圾回收。 但是在Python中，对于有多个元素组成的对象，可能还会有循环引用的问题，为了解决这个问题，Python又引用了标记清除和分代回收，所以在Python内部实际上要维护四个双向环状链表，分别是： refchain 0代 700个 1代 0代扫描10次 2代 1代扫描10次在源码内部，当达到各自的阈值时，就会扫描链表，发现循环引用就会想相关对象的引用计数器减一，如果引用计数器的值被减为0，那么这个对象就会被销毁，这个对象占用的内存空间就会被回收。 优化：缓存在Python内部，源码对上述过程进行了优化，这个优化就是缓存。 1.内存池为了避免重复创建和销毁一些常见对象，就会维护一个内存池。 在启动Python解释器时，内部会自动为我们创建-5~256这些数字放到内存池中，如果有变量需要指向这些值，内存不会开辟新的内存，直接从内存池中取。 所以如果： 12v1 &#x3D; 8v2 &#x3D; 8 打印一下v1和v2的id，会发现他们的id是相同的。 而且内存池中的对象，他们的引用计数器不会变为0，因为初始化的时候，他们的引用计数器就为1，这时候没有变量引用他们，所以当引用他们的变量引用后又不再引用他们的时候，他们的引用计数器也不会变为0。 2.free_list当一个对象的引用计数器变为0时，先不回收，而是把这个对象放到free_list中，当作缓存，这样再创建对象时，就不开辟新的内存，直接使用free_list中的对象的内存，把这块内存初始化，再把这个对象放到refchain中。 当然这个缓冲池也是有大小限制的，如果一个对象的引用计数器变为0，而此时缓冲池也已经满了，那么这个对象还是会被直接销毁的。 float，list，tuple，dict采用这种机制。 float类型，维护的free_list链表最多可缓存100个float对象。 list类型，维护的free_list链表最多可缓存80个list对象。 dict类型，维护的free_list链表最多可缓存80个dict对象。 tuple类型的比较特殊，可以理解为如果是tuple类型的，free_list的容量为20，这时候的free_list有20个index，index从0到19，每个索引位置都存放了一个链表，index为0的位置，存放的是空元组，index为1的位置存放的是元组长度为1的元组，这样以此类推。每一个链表都可以存放2000个元组。 字符串类型的有两种优化方式：1.字符池2.字符串驻留机制 字符池就是和int的内存池类似，python内部会将ASCII的所有字符存在一个叫unicode_latin[256]的链表中。 字符串驻留机制：python会将只有字母、数字、下划线并且长度不大于20的字符串进行驻留，放到内存，如果下次再创建一个一模一样的值，就不再开辟新的内存空间。 详见：https://pythonav.com/wiki/detail/6/88/","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python的*args和**kwargs","slug":"Python的args和kwargs","date":"2020-08-13T01:42:15.000Z","updated":"2020-08-14T03:43:38.104Z","comments":true,"path":"2020/08/13/Python的args和kwargs/","link":"","permalink":"http://yoursite.com/2020/08/13/Python%E7%9A%84args%E5%92%8Ckwargs/","excerpt":"当定义一个函数，这个函数可能会有不定长参数的时候，就会在函数的接收参数的括号的最后加上*args, **kwargs。 *agrs用来接收非关键字参数，以元组的形式保存，这个形参的名字叫args(非关键字参数就是直接传递进来的，没有名字的参数，与关键字参数相对)。 **kwargs用来接收关键字参数，以字典的形式保存，这个形参的名字叫kwargs(关键字参数就是有名字的参数，比如传递进来的age=12)。","text":"当定义一个函数，这个函数可能会有不定长参数的时候，就会在函数的接收参数的括号的最后加上*args, **kwargs。 *agrs用来接收非关键字参数，以元组的形式保存，这个形参的名字叫args(非关键字参数就是直接传递进来的，没有名字的参数，与关键字参数相对)。 **kwargs用来接收关键字参数，以字典的形式保存，这个形参的名字叫kwargs(关键字参数就是有名字的参数，比如传递进来的age=12)。 也可以把args和kwargs起成别的名字。 当前程序： 1234567def test(a, b, *args, **kwargs): print(a) print(b) print(args) print(kwargs)test(11, 22) 运行一下： 12345D:\\&gt;python test09.py1122()&#123;&#125; 这时候a，b接收了11和22，而args和kwargs没有接收参数，所以为空元组和空字典。 如果再传递几个非关键字参数： 1test(11, 22, 33, 44, 55, 66) 运行： 12345In [4]: test(11, 22, 33, 44, 55, 66)1122(33, 44, 55, 66)&#123;&#125; 这时候多余的非关键字参数都被传递到了args里，作为一个元组保存起来。 再传递几个关键字参数： 12345In [6]: test(11, 22, 33, 44, 55, 66, name&#x3D;&quot;happy&quot;, age&#x3D;100)1122(33, 44, 55, 66)&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125; 如果定义两个函数test01和test02，给test01传递一些参数，test01再把这些参数传递给test02： 123456789101112131415161718def test01(a, b, *args, **kwargs): print(&quot;test01&quot;) print(a) print(b) print(args) print(kwargs) test02(a, b, args, kwargs)def test02(a, b, *args, **kwargs): print(&quot;test02&quot;) print(a) print(b) print(args) print(kwargs)test01(11, 22, 33, 44, 55, 66, name&#x3D;&quot;happy&quot;, age&#x3D;100) 运行： 1234567891011D:\\&gt;python test09.pytest011122(33, 44, 55, 66)&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;test021122((33, 44, 55, 66), &#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;)&#123;&#125; 这时候，传给test01的除了a和b的所有参数都被test02当作一个元组存起来了。这是因为，传递给test01的是 1234a &#x3D; 11b &#x3D; 22args &#x3D; (33, 44, 55, 66)kwargs &#x3D; &#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125; 这时候再传递给test02，test02把11给了a，把22给了b，后面两个参数是一个元组一个字典，都是非关键字参数，所以就一起给了args。 所以如果想把传递给test01的参数原封不动的传给test02，就需要把元组和字典拆包，实现方法是在args前面加一个“”，在kwargs前加一个“*”。 123456789101112131415161718def test01(a, b, *args, **kwargs): print(&quot;test01&quot;) print(a) print(b) print(args) print(kwargs) test02(a, b, *args, **kwargs)def test02(a, b, *args, **kwargs): print(&quot;test02&quot;) print(a) print(b) print(args) print(kwargs)test01(11, 22, 33, 44, 55, 66, name&#x3D;&quot;happy&quot;, age&#x3D;100) 运行： 1234567891011D:\\&gt;python test09.pytest011122(33, 44, 55, 66)&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125;test021122(33, 44, 55, 66)&#123;&#39;name&#39;: &#39;happy&#39;, &#39;age&#39;: 100&#125; 所以def test01(a, b, *args, **kwargs):表示可以接收不定长的参数，以元组或字典保存。 而test02(a, b, *args, **kwargs)表示的是拆包，把元组拆成单个元素，把字典拆成变量名=某个值的形式。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"深入浅出Python多任务（线程，进程，协程）","slug":"深入浅出Python多任务（线程，进程，协程）","date":"2020-08-12T01:42:15.000Z","updated":"2020-08-13T13:40:10.572Z","comments":true,"path":"2020/08/12/深入浅出Python多任务（线程，进程，协程）/","link":"","permalink":"http://yoursite.com/2020/08/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E5%A4%9A%E4%BB%BB%E5%8A%A1%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%EF%BC%89/","excerpt":"导入看一下下面的程序：","text":"导入看一下下面的程序： 123456789101112131415161718192021import timedef sing(): for i in range(5): print(&quot;sing....&quot;) time.sleep(1)def dance(): for i in range(5): print(&quot;dancing...&quot;) time.sleep(1)def main(): sing() dance()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行这个程序，输出结果如下： 1234567891011$ python test01.pysing....sing....sing....sing....sing....dancing...dancing...dancing...dancing...dancing... 一共花费了十秒。 修改程序为多任务的程序： 123456789101112131415161718192021222324import timeimport threadingdef sing(): for i in range(5): print(&quot;sing....&quot;) time.sleep(1)def dance(): for i in range(5): print(&quot;dancing...&quot;) time.sleep(1)def main(): t1 &#x3D; threading.Thread(target&#x3D;sing) t2 &#x3D; threading.Thread(target&#x3D;dance) t1.start() t2.start()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行这个程序： 1234567891011$ python test02.pysing....dancing...dancing...sing....dancing...sing....dancing...sing....dancing...sing.... 所谓的多任务，就是同时可以做多件事情。 一台计算机同时可以做多少件事情，是由CPU觉得的，如果CPU的双核的，说明同时可以做两件事情，如果是四核的，就可以同时做四件事情。 如果计算机是单核的，怎么实现多任务？ 一个比较好理解的办法是，时间片轮转，比如当前有四个程序，CPU是一核的，那么就让第一个程序先执行0.00001s，然后让下一个程序再执行0.00001s，这样每个程序都执行了0.00001s之后，再来执行第一个程序。因为人是察觉不到0.0001s的切换的，所以在我们看来，程序就像在“一起”执行一样，这样的多任务，叫并发，并发是加到多任务。 如果计算机是双核的，现在有两个程序，那么这两个程序可以同时执行，这样真的一起同时在执行叫做“并行”，并行是真的多任务。 线程那么怎样才能让Python程序完成多任务呢。 线程就是实现多任务的一种手段。 1.threading模块在Python中有一个模块是threading，这个模块中有一个类是Thread，用法如下： 1234567def test(): while True: print(&quot;123456&quot;)# target接收的是函数名，不是函数的调用t1 &#x3D; threading.Thread(target &#x3D; test)t1.start() 类名+“（）”就创建了一个对象，这个对象就是之后要启动的线程。 当t1.start()的时候，这个线程就真正开始创建并被执行。 还是这个程序： 123456789101112131415161718192021222324import timeimport threadingdef sing(): for i in range(5): print(&quot;sing....&quot;) time.sleep(1)def dance(): for i in range(5): print(&quot;dancing...&quot;) time.sleep(1)def main(): t1 &#x3D; threading.Thread(target&#x3D;sing) t2 &#x3D; threading.Thread(target&#x3D;dance) t1.start() t2.start()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 主线程从上往下执行，当走到def sing的时候，不进入函数执行，因为这是一个函数的定义，继续往下走，到dance的时候也不执行，走到main也不执行，遇到if __name__ == &quot;__main__&quot;:执行调用里面的main()，然后进入main这个函数。 t1 = threading.Thread(target=sing)的时候，创建了一个对象，把它赋给了t1，遇到t2 = threading.Thread(target=dance)的时候，创建了一个对象，把它赋给了t2。 当主线程运行到t1.start()的时候，主线程创建了一个子线程，这个子线程去执行sing函数，主线程继续往下执行，当遇到t2.start()的时候，主线程创建另外一个子线程，这个子线程去执行dance函数。 主线程往下就没有执行的代码了，这时候主线程会等待子线程执行结束，然后主线程再结束。 2.查看线程的数量threading模块中有一个有一个方法是enumerate，只要调用threading.enumerate()他的返回值就是一个列表，这个列表中的元素就是主线程和子线程。 修改程序如下： 12345678910111213141516171819202122import threadingdef sing(): for i in range(5): print(&quot;sing....&quot;)def dance(): for i in range(5): print(&quot;dancing...&quot;)def main(): t1 &#x3D; threading.Thread(target&#x3D;sing) t2 &#x3D; threading.Thread(target&#x3D;dance) t1.start() t2.start() print(threading.enumerate())if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 然后执行程序： 123456789101112$ python test01.pysing....sing....sing....sing....sing....dancing...dancing...dancing...dancing...dancing...[&lt;_MainThread(MainThread, started 9080)&gt;] 发现打印出来的线程里面只有一个是主线程，没有其他两个子线程。 原因是当主线程走到t1.start()的时候创建了一个子线程，在t2.start()的时候又创建了一个子线程，然后主线程继续往下走，走到print，这时候这个程序有三个线程，又因为这三个线程都是没有延迟的，所以先让哪个线程执行就取决于操作系统，操作系统在调度这三个线程的时候，让谁先执行是不确定的。所以线程的执行是没有先后顺序的。 如果想让某个线程先执行可以采用一个方法就是让其他的线程延时。 想要看到系统什么时刻有哪几个线程在运行，方法如下： 修改代码如下： 12345678910111213141516171819202122232425262728293031import threadingimport timedef sing(): for i in range(5): print(&quot;sing....第%d秒--&quot; % i) time.sleep(1)def dance(): for i in range(10): print(&quot;dancing...第%d秒--&quot; % i) time.sleep(1)def main(): t1 &#x3D; threading.Thread(target&#x3D;sing) t2 &#x3D; threading.Thread(target&#x3D;dance) t1.start() t2.start() while True: print(threading.enumerate()) time.sleep(1) if len(threading.enumerate()) &lt;&#x3D; 1: breakif __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 循环打印当前系统中的线程，如果当前系统中只剩下一个线程，就是主线程，那么就退出循环。 执行程序： 1234567891011121314151617181920212223242526$ python test01.pysing....▒▒0▒▒--dancing...▒▒0▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒1▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]sing....▒▒1▒▒--sing....▒▒2▒▒--dancing...▒▒2▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒3▒▒--sing....▒▒3▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒4▒▒--sing....▒▒4▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-1, started 12124)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒5▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;][&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒6▒▒--dancing...▒▒7▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒8▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;]dancing...▒▒9▒▒--[&lt;_MainThread(MainThread, started 14184)&gt;, &lt;Thread(Thread-2, started 16304)&gt;] 可以看到每一秒钟程序的线程，前五秒是三个线程，到了第五秒，程序里面有两个线程，因为循环5次，每次休眠1秒的sing线程结束了，然后到了第十秒，第二个子线程也执行完了，程序中就只剩一个主线程，所以退出循环不打印了。这时候主线程也结束，程序结束。 所以如果创建Thread来执行函数，当这个函数执行完，这个子线程也就结束了。 主线程结束，程序就结束了。所以主线程会等待所有的子线程执行结束再结束。 3.子线程是什么时候被创建的，什么时候被执行的12345678910In [1]: import threadingIn [2]: def test(): ...: print(&quot;------1--------&quot;) ...:In [3]: t1 &#x3D; threading.Thread(target&#x3D;test)In [4]: t1.start()------1-------- 当t1被赋值的时候，test函数并没有被调用没有被执行，而是start的时候test函数才被执行，所以说明线程是在被调用的时候才执行。 那线程是什么时候被创建的? 是t1 = threading.Thread(target=test)的时候被创建的，还是t1.start()的时候被创建的？ 1234567891011121314151617import threadingimport timedef sing(): for i in range(5): print(&quot;sing....&quot;) time.sleep(1)def main(): print(threading.enumerate()) t1 &#x3D; threading.Thread(target&#x3D;sing) print(threading.enumerate()) t1.start() print(threading.enumerate())if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 在t1 = threading.Thread(target=sing)之前查看当前程序有多少线程，在t1 = threading.Thread(target=sing)之后查看当前程序有多少线程，在start之后再查看一次。 运行程序： 123456789$ python test01.py[&lt;_MainThread(MainThread, started 11772)&gt;][&lt;_MainThread(MainThread, started 11772)&gt;]sing....[&lt;_MainThread(MainThread, started 11772)&gt;, &lt;Thread(Thread-1, started 11456)&gt;]sing....sing....sing....sing.... 在start前打印的两次线程中，都没有线程Thread-1，说明当t1.start()的时候，线程才真正被创建和执行。 所以当调用Thread的时候，不会创建线程，当调用Thread创建出来的实例对象的start方法的时候线程才会被创建，以及开始运行线程。 总结： 如果想完成多任务，就可以通过Thread创建一个对象，这个对象一调用start，子线程就会被创建和执行，这个对象执行什么就看传递的target是哪个函数名。当这个被执行的函数结束了，这个子线程就结束了。 线程真正创建是start，真正结束是函数结束。 多个线程被创建之后，执行顺序是不确定的，执行顺序取决于操作系统，如果想指定执行的先后顺序，可以通过延时来实现。 主线程最后结束，因为主线程结束程序就结束了。 创建Thread对象这个过程可以理解为线程的准备工作。 4.target也可以是一个类当target是一个类的时候，写法就有变化了。 例如： 123456789101112131415import threadingimport timeclass MyThread(threading.Thread): def run(self): for i in range(5): print(i) time.sleep(i)def main(): t &#x3D; MyThread() t.start() if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 用类来创建线程的时候，直接把类实例化一个对象传给t就可以，调用的时候还是t.start()就可以。 这个类必须要继承threading.Thread，这个类里必须定义run方法，线程start之后，会自动调用run方法，执行run里面的代码。 类中没有定义start方法，这个start方法是继承自Thread的方法。 所以创建线程有两种方式： t1 = threading.Thread(target=函数名) 函数里面的代码是什么，线程就去执行什么 用类定义一个类，这个类必须继承threading.Thread，而且这个类必须实现run方法，这个run方法中写了什么，线程就去执行什么。 这种方式适合一个线程做的事情比较复杂，而且涉及多个函数，一般就把这些函数封装成一个类。 相比较而言，函数的方式更加简单。 如果类中还有其他函数想要在线程执行的适合执行，那么这个函数的调用可以写在run函数中。 5.多个线程之间共享全局变量修改全局变量前提： 在一个函数中，对全局变量进行修改的时候，到底是否需要使用global取决于是否对变量的指向进行了修改。 如果进行了修改，即让全局变量指向了一个新的地方，那么必须使用global 如果仅仅是修改了全局变量指向空间的数据，就不必须使用global能不能修改还看全局变量是否可变，数字、字符串、元组不可变 例如，如果全局变量是数字： 1234567891011121314In [9]: num &#x3D; 100In [10]: def test(): ...: global num ...: num +&#x3D; 100 ...:In [11]: print(num)100In [12]: test()In [13]: print(num)200 此时修改全局变量就要加global。 如果不加： 123456789101112131415161718192021222324In [16]: num &#x3D; 100In [17]: def test(): ...: num +&#x3D; 100 ...:In [18]: print(num)100In [19]: test()---------------------------------------------------------------------------UnboundLocalError Traceback (most recent call last)&lt;ipython-input-19-fbd55f77ab7c&gt; in &lt;module&gt;----&gt; 1 test()&lt;ipython-input-17-fabd8b626a8d&gt; in test() 1 def test():----&gt; 2 num +&#x3D; 100 3UnboundLocalError: local variable &#39;num&#39; referenced before assignmentIn [20]: print(num)100 如果全局变量是可变对象，不修改它的指向： 12345678910111213In [22]: nums &#x3D; [11,22]In [23]: def test(): ...: nums.append(33) ...:In [24]: print(nums)[11, 22]In [25]: test()In [26]: print(nums)[11, 22, 33] 如果全局变量是可变对象，修改它的指向： 123456789101112131415161718192021222324In [28]: nums &#x3D; [11,22]In [29]: def test(): ...: nums +&#x3D; [33] ...:In [30]: print(nums)[11, 22]In [31]: test()---------------------------------------------------------------------------UnboundLocalError Traceback (most recent call last)&lt;ipython-input-31-fbd55f77ab7c&gt; in &lt;module&gt;----&gt; 1 test()&lt;ipython-input-29-8d9294d083c5&gt; in test() 1 def test():----&gt; 2 nums +&#x3D; [33] 3UnboundLocalError: local variable &#39;nums&#39; referenced before assignmentIn [32]: print(nums)[11, 22] 验证线程之间是共享全局变量的方法： 1.创建两个线程，一个用来修改全局变量，一个在修改完全局变量后打印这个全局变量。 12345678910111213141516171819202122232425262728import threadingimport time# 全局变量num &#x3D; 100def test01(): global num num +&#x3D; 100 print(&quot;test01: num &#x3D; %d&quot; % num)def test02(): print(&quot;test02: num &#x3D; %d&quot; % num)def main(): t1 &#x3D; threading.Thread(target&#x3D;test01) t2 &#x3D; threading.Thread(target&#x3D;test02) t1.start() time.sleep(1) t2.start() time.sleep(1) print(&quot;main thread: num &#x3D; %d&quot; % num)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行： 1234$ python test01.pytest01: num &#x3D; 200test02: num &#x3D; 200main thread: num &#x3D; 200 说明线程之间是共享全局变量的。 2.把全局变量当作参数传给函数 修改程序如下： 1234567891011121314151617181920212223242526import threadingimport timedef test01(tmp1): tmp1.append(33) print(&quot;test01: tmp &#x3D; %s&quot; % str(tmp1))def test02(tmp2): print(&quot;test02: tmp &#x3D; %s&quot; % str(tmp2))nums &#x3D; [11,22]def main(): t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(nums,)) t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(nums,)) t1.start() time.sleep(1) t2.start() time.sleep(1) print(&quot;main thread: nums &#x3D; %s&quot; % str(nums))if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() args是要传递给函数的数据，这个数据必须是个元组，就是需要写括号，可以传递多个参数，参数最后多加一个逗号“,”，不然会报错。 运行这个程序： 1234$ python test01.pytest01: tmp &#x3D; [11, 22, 33]test02: tmp &#x3D; [11, 22, 33]main thread: nums &#x3D; [11, 22, 33] 6.共享全局变量可能遇到的问题：资源竞争可能遇到资源竞争的问题。 定义两个函数，他们都用来把全局变量加1，循环100次，这样如果这两个函数都执行完，如果全局变量一开始是0，那么执行完两个函数就应该是200。 程序如下： 12345678910111213141516171819202122232425262728293031import threadingimport time# 全局变量global_num &#x3D; 0def test01(num): global global_num for i in range(num): global_num +&#x3D; 1 print(&quot;test01: num &#x3D; %d&quot; % global_num)def test02(num): global global_num for i in range(num): global_num +&#x3D; 1 print(&quot;test02: num &#x3D; %d&quot; % global_num)def main(): t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(100,)) t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(100,)) t1.start() t2.start() time.sleep(5) print(&quot;main thread: num &#x3D; %d&quot; % global_num)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行程序： 1234$ python test01.pytest01: num &#x3D; 100test02: num &#x3D; 200main thread: num &#x3D; 200 这时候执行结果是正确的。 如果不是循环100次，而是循环1000000次，那么结果应该是2000000。 修改程序： 12345678910111213141516171819202122232425262728293031import threadingimport time# 全局变量global_num &#x3D; 0def test01(num): global global_num for i in range(num): global_num +&#x3D; 1 print(&quot;test01: num &#x3D; %d&quot; % global_num)def test02(num): global global_num for i in range(num): global_num +&#x3D; 1 print(&quot;test02: num &#x3D; %d&quot; % global_num)def main(): t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(1000000,)) t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(1000000,)) t1.start() t2.start() time.sleep(5) print(&quot;main thread: num &#x3D; %d&quot; % global_num)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行程序： 1234$ python test01.pytest01: num &#x3D; 1132201test02: num &#x3D; 1402099main thread: num &#x3D; 1402099 这时候执行结果就出错了。 因为global_num += 1这个语句在执行的时候，会分成几步，1.先取到global_num的值。2.把这个值加一。3.把这个值存起来。 操作系统如果使用了时间片轮转法，在global_num等于0的时候，线程1取到了0这个值，然后把它加一，变成了1，这时候操作系统去执行线程2，取到的值还是0，把它加一，然后存储起来，这时候global的值为1，操作系统再去执行线程1，线程1把它计算的1保存，这时候global的值依旧为1，所以虽然global的值被计算了两次，但是实际得到的结果是错误的。 所以如果多线程共享全局变量，而且同一时刻都在操作全局变量，就可能出现问题，这就是资源竞争。 7.解决资源竞争问题可以通过线程同步来解决问题。 同步就是协同步调，协同就是一个先执行，再执行另一个，互相配合着执行。 同步可以用互斥锁来实现。 互斥锁就是当线程1要修改全局变量之前，先把这个全局变量上锁，这样其他的线程就无法修改这个数据，当前线程1用完这个全局变量后，再把锁解开。 互斥锁的创建： 12345678# 创建所mutex &#x3D; threading.Lock()# 锁定mutex.acquire()# 释放mutex.release() 如果一个数据是没有上锁的，那么acquire不会堵塞。 如果这个数据已经被其他线程锁定了，那么此时再上锁（acquire），会堵塞，当其他线程解锁之后，当前的线程才能上锁。 互斥锁解决资源竞争问题： 创建一个全局变量是锁： 12345678910111213141516171819202122232425262728293031323334353637383940import threadingimport time# 全局变量global_num &#x3D; 0def test01(num): global global_num # 上锁 mutex.acquire() for i in range(num): global_num +&#x3D; 1 mutex.release() print(&quot;test01: num &#x3D; %d&quot; % global_num)def test02(num): global global_num mutex.acquire() for i in range(num): global_num +&#x3D; 1 mutex.release() print(&quot;test02: num &#x3D; %d&quot; % global_num)# 创建一个互斥锁，默认没有上锁mutex &#x3D; threading.Lock()def main(): t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(1000000,)) t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(1000000,)) t1.start() t2.start() time.sleep(5) print(&quot;main thread: num &#x3D; %d&quot; % global_num)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行程序： 1234$ python test01.pytest01: num &#x3D; 1000000test02: num &#x3D; 2000000main thread: num &#x3D; 2000000 这时候结果是正确的，线程1和线程2不一定哪个线程会先抢到这把锁，如果一个线程给全局变量上锁了，另一个线程只能等待这个线程解锁，才能上锁，对全局变量进行操作。 上锁有一个原则是锁定的代码越少越好，所以修改程序如下： 123456789101112131415161718192021222324252627282930313233343536373839import threadingimport time# 全局变量global_num &#x3D; 0def test01(num): global global_num for i in range(num): mutex.acquire() global_num +&#x3D; 1 mutex.release() print(&quot;test01: num &#x3D; %d&quot; % global_num)def test02(num): global global_num for i in range(num): mutex.acquire() global_num +&#x3D; 1 mutex.release() print(&quot;test02: num &#x3D; %d&quot; % global_num)# 创建一个互斥锁，默认没有上锁mutex &#x3D; threading.Lock()def main(): t1 &#x3D; threading.Thread(target&#x3D;test01,args&#x3D;(1000000,)) t2 &#x3D; threading.Thread(target&#x3D;test02,args&#x3D;(1000000,)) t1.start() t2.start() time.sleep(5) print(&quot;main thread: num &#x3D; %d&quot; % global_num)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 执行程序： 执行第一遍： 1234$ python test01.pytest01: num &#x3D; 1921277test02: num &#x3D; 2000000main thread: num &#x3D; 2000000 执行第二遍： 1234$ python test01.pytest01: num &#x3D; 1884133test02: num &#x3D; 2000000main thread: num &#x3D; 2000000 这是因为，因为加锁只加了global_num += 1这一行代码，所以有可能出现在线程1执行完之前，线程1给global_num 加了一些值，线程2也给global加了一些值，所以到线程1执行完之前，global被加了超过1000000次，所以有了这样的结果。 8.互斥锁带来的死锁问题如果有两个资源，资源A和资源B，有两个线程，线程1和线程2。 线程1要先使用资源A，然后使用资源B，线程2要先使用资源B，再使用资源A。 如果线程1先给A上了锁，然后使用了A，进行一些操作，与此同时，线程2给B上了锁，进行了一些操作。 这时候线程1要使用资源B，发现资源B被上锁了，那线程1就等待线程2解锁。 线程2要使用资源A，发现资源A被上锁了，那线程2就等待线程1解锁。 两个线程就一直等待互相释放资源，这种现象就是死锁。 如何解决死锁问题： 1.银行家算法：设计程序时尽量避免死锁 2.添加超时时间 银行家算法： 如果一个银行家有10块钱，有三个客户要贷款，客户A要贷款9块钱，客户B要贷款3块钱，客户C要贷款8块钱。 那么这个时候，银行家手里的钱不足以让三个客户都拿到贷款。 这个时候，先借给客户A 2块钱，借给客户B 2块钱，借给客户C 4块钱，这时候银行家手里还有2块钱。 银行家 客户A(9) 客户B(3) 客户C(8) 10 0 0 0 2 2 2 4 这时候银行家手里的2块钱借给客户B 1块钱，告诉其他的客户剩下的前过几天再借给他。 银行家 客户A(9) 客户B(3) 客户C(8) 10 0 0 0 2 2 2 4 1 2 3（满足） 4 和客户B约定好还钱的时间，当客户B归还了3块钱的时候，银行家手里就有了4块钱，把这4块钱再借给客户C。 银行家 客户A(9) 客户B(3) 客户C(8) 10 0 0 0 2 2 2 4 1 2 3（满足） 4 4 2 （已归还） 4 0 2 （已归还） 8 这之后客户C用完了钱，归还后再借给A 7块钱。 银行家 客户A(9) 客户B(3) 客户C(8) 10 0 0 0 2 2 2 4 1 2 3（满足） 4 4 2 （已归还） 4 0 2 （已归还） 8 8 2 （已归还） （已归还） 1 9 （已归还） （已归还） 最后客户A归还了钱，银行家收获了利息。 所以，每个客户必须一开始就声明他们所要借款或贷款的总额，然后银行家根据资源的情况和客户的情况先算好什么时候借给谁，什么时候谁归还。 这个想法应用到操作系统，操作系统就是这个银行家，它必须提前计算好每个线程何时上锁，何时解锁，这样就在程序执行之前避免了死锁。 添加超时时间就是为死锁设定一个超时时间，如果两个线程产生了死锁，到达这个超时时间之后，采用kill线程的方式解开死锁。 进程实现多任务的另一种方式。 程序是静态的，是一个exe文件或者是其他的东西，运行起来就是进程，一个进程包含多个线程。 一个程序一般来说可以开多个，比如QQ程序，打开之后就是多个QQ进程。 进程是启动的程序，所以进程比程序多拥有了资源，比如QQ进程可以使用内存资源，可以通过网卡连接网络，以及鼠标键盘等资源。所以进程是一个资源分配的单位。 1.使用进程实现多任务程序如下： 1234567891011121314151617181920212223import threadingimport timeimport multiprocessingdef test1(): while True: print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) time.sleep(1)def test2(): while True: print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) time.sleep(1)def main(): t1 &#x3D; multiprocessing.Process(target&#x3D;test1) t2 &#x3D; multiprocessing.Process(target&#x3D;test2) t1.start() t2.start()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 运行程序： 123456789101112131415161718D:\\&gt;python test02.py&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111111&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 此时如果是Windows系统可以在另外一个终端输入tasklist命令来查看当前系统运行的所有进程。 一部分如下： 12345678映像名称 PID 会话名 会话&#39;# 内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;chrome.exe 11504 Console 1 51,440 Kchrome.exe 10496 Console 1 21,892 Kpython.exe 7680 Console 1 11,908 Kpython.exe 5356 Console 1 12,032 Kpython.exe 8984 Console 1 12,036 Ktasklist.exe 6004 Console 1 9,028 K 当结束程序，再次查看： 123456789映像名称 PID 会话名 会话&#39;# 内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;conhost.exe 11024 Console 1 16,896 Kchrome.exe 11224 Console 1 91,268 Kchrome.exe 12280 Console 1 71,120 Kchrome.exe 1608 Console 1 66,956 Kchrome.exe 11504 Console 1 51,436 Kchrome.exe 10496 Console 1 21,896 Ktasklist.exe 7740 Console 1 9,016 K 发现python的程序已经没有了。 如果是linux系统可以用ps -aux来查看。 Windows系统用taskkill /pid 端口 /F来停止进程： 12D:\\&gt;taskkill &#x2F;pid 1996 &#x2F;F成功: 已终止 PID 为 1996 的进程。 linux系统可以用kill + 进程ID来停止进程。 当主进程从上到下扫描代码，开始执行时，执行到t1.start()这一行，会创建一个新的子进程，这个新的子进程拥有另一份属于自己的资源，新的子进程被创建的时候，要修改的东西会拷贝一份自己的，不修改的就不拷贝了，共享代码（因为在运行过程中不会修改代码），也就是说能共享的就会共享，不能共享的就复制一份自己的（所以有一个概念是“写时拷贝”，即修改的时候拷贝）。所以多进程会占用较大的资源，所以进程数不是越多越好。 所以在执行刚刚的程序时，可以看到三个Python进程，一个是主进程，另外两个是子进程。 2.进程和线程的对比进程：是资源的总称，包括代码，包括内存等。 线程：比较轻量级，线程之间资源共享。 进程仅仅是一个资源分配的单位，是一个资源总和，而线程是操作系统调度的单位。 多线程是在同一份资源的前提下执行代码，而多进程是多份资源，同一份代码或多份代码，各自使用各自的资源去执行。 每一个进程都至少拥有一个线程（主线程），真正去执行的是线程。也就是说每创建一个进程，这个进程就会有一个主线程去使用资源执行代码。 进程依赖与进程，比如一个网易云音乐运行之后是一个进程，这个进程可以开启多个线程，比如下载歌曲线程和播放歌曲线程，这两个线程之间共享资源，下载后的歌曲可以由播放线程来播放，但是一旦关闭网易云，就是关闭了进程，线程也就不存在了。 进程之间是互相独立的，比如QQ音乐和网易云音乐之间是独立的。 3.使用队列完成进程间通信如果想使用多进程来实现多任务，比如想用一个进程来下载音乐，一个进程来播放下载好的音乐，那进程之间就需要进行通信。 进程间通信的一种方式是队列：Queue。 Queue如何使用： 123456789101112131415161718192021# 使用Queue要导入这个模块import multiprocessing# 创建队列，括号中可以填一个数字，表示创建的队列中可以放多少元素，队列中的元素可以放不同数据类型的数据q &#x3D; multiprocessing.Queue()q &#x3D; multiprocessing.Queue(3)# 往队列中存放数据q.put()# 从队列中取数据，如果这时候队列为空，q.get()就会一直等待，等到队列中有数据了再取出来。q.get()# 如果不想等待可以使用get_nowait，但是如果这时候队列中没有数据，就会抛异常。q.get_nowait()# 判断队列是否为空，如果为空，返回True，否则返回Falseq.empty()# 判断队列是否已满，已满则返回True，否则返回Falseq.full() 进程之间通过Queue通信的实现：一个进程用来下载数据，这个进程把下载好的数据存放在队列中，另一个进程从这个队列取数据来进行操作。 代码： 123456789101112131415161718192021222324252627import multiprocessingdef download(q): data &#x3D; [11, 22, 33, 44] for tmp in data: q.put(tmp) print(&quot;download OK!&quot;)def use(q): res &#x3D; [] while not q.empty(): res.append(q.get()) print(&quot;res is:&quot;) print(res)def main(): q &#x3D; multiprocessing.Queue() p1 &#x3D; multiprocessing.Process(target&#x3D;download, args&#x3D;(q,)) p2 &#x3D; multiprocessing.Process(target&#x3D;use, args&#x3D;(q,)) p1.start() p2.start()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 运行程序： 1234$ python test02.pydownload OK!res is:[11, 22, 33, 44] 4.进程池进程的创建和销毁需要消耗很多资源。所以为了减少创建和消耗进程的次数，使用进程池，先创建好固定数量的进程，如果需要执行程序，让这些进程去执行，当执行结束后，把这些进程再放入进程池，这样可以反复利用创建好的进程，不用反复的创建和销毁。 进程池Pool的使用 123456789101112131415# Pool也是在multiprocessing这个包中from multiprocessing import Pool# 传递参数，进程池里放多少进程，也可以不传参数pool &#x3D; Pool(3)# pool.apply_async(调用的目标,(传递的参数元组,)) 这里的逗号是必须的。# 用进程池里空闲的子进程去调用目标，如果当前没有空闲的子进程，任务也会被添加到进程池里，等待子进程空闲的时候去执行pool.apply_async(work,(i,))# 关闭进程池，不再接收新的请求pool.close()# 等待所有的子进程结束再结束程序，必须放在close语句之后，如果没有这句话，不能保证子进程都执行完毕。因为通过进程池创建的子进程，主进程不会自动等待他们执行完毕。pool.join() 123456789101112131415161718192021from multiprocessing import Poolimport timedef work(num): print(&quot;------start-------&quot;) time.sleep(1) print(num) print(&quot;------end---------&quot;)def main(): pool &#x3D; Pool(3) for i in range(10): pool.apply_async(work,(i,)) print(&quot;------come to close---------&quot;) pool.close() pool.join() print(&quot;------come to an end--------&quot;)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 运行程序： 123456789101112131415161718192021222324252627282930313233$ python test03.py------start-------2------end---------------start-------5------end---------------start-------6------end---------------start-------0------end---------------start-------4------end---------------start-------7------end---------------start-------1------end---------------start-------3------end---------------start-------8------end---------------start-------9------end---------------come to close---------------come to an end-------- 可以看到，进程的调度顺序也是不确定的。 5.多进程实现复制文件夹下的多个文件1.获取要复制的文件夹的名字 2.创建一个新的文件夹 3.获取文件夹所有要复制的文件名字 4.创建进程池，主进程往进程池里添加要复制的文件 5.子进程把文件复制到新的文件夹中去 当前有如下文件夹及文件： 123&#x2F;d&#x2F;test:$ ls1.py 2.py 3.py 4.py 5.py 6.py 7.py 8.py 9.py 代码： 12345678910111213141516171819202122232425262728293031323334import osimport multiprocessingdef copy(file, old_folder, new_folder): old_f &#x3D; open(old_folder + &quot;&#x2F;&quot; + file, &quot;rb&quot;) content &#x3D; old_f.read() old_f.close() new_f &#x3D; open(new_folder + &quot;&#x2F;&quot; + file, &quot;wb&quot;) new_f.write(content) new_folder.close()def main(): source_folder &#x3D; &#39;test&#39; try: new_folder &#x3D; source_folder + &quot;_copy&quot; os.mkdir(new_folder) except: pass files &#x3D; os.listdir(source_folder) pool &#x3D; multiprocessing.Pool(5) for f in files: pool.apply_async(copy, (f, source_folder, new_folder)) pool.close() pool.join()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 运行程序： 1$ python test04.py 查看当前目录： 12test.py test_copy&#x2F; 已经成功复制了test，进入test_copy目录下，看看文件是否复制成功： 12$ ls test_copy&#x2F;1.py 2.py 3.py 4.py 5.py 6.py 7.py 8.py 9.py 已经成功复制了。 改进： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osimport multiprocessingdef copy(queue, file, old_folder, new_folder): old_f &#x3D; open(old_folder + &quot;&#x2F;&quot; + file, &quot;rb&quot;) content &#x3D; old_f.read() old_f.close() new_f &#x3D; open(new_folder + &quot;&#x2F;&quot; + file, &quot;wb&quot;) new_f.write(content) new_folder.close() queue.put(file)def main(): source_folder &#x3D; &#39;test&#39; try: new_folder &#x3D; source_folder + &quot;_copy&quot; os.mkdir(new_folder) except: pass files &#x3D; os.listdir(source_folder) pool &#x3D; multiprocessing.Pool(5) queue &#x3D; multiprocessing.Manager().Queue() for f in files: pool.apply_async(copy, (queue, f, source_folder, new_folder)) pool.close() # pool.join() lenth &#x3D; len(files) num &#x3D; 0 while True: try: name &#x3D; queue.get_nowait() except: pass num +&#x3D; 1 print(&quot;\\r拷贝进度为 %.2f %%&quot; % (num*100&#x2F;lenth), end&#x3D;&quot;&quot;) if num &gt;&#x3D; lenth: breakif __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 这里使用的不是multiprocessing下的Queue，而是multiprocessing下的manager下的Queue。 结合了进程之间使用Queue进行通信，实现多进程复制文件。 用一个简单的方式打印了拷贝进度。 运行： 12D:\\&gt;python test04.py拷贝进度为 100.00 % 协程1.迭代器12for tmp in a: print(tmp) 如果a是可以在上面的代码里使用的数据类型，a就是可迭代对象。 元组，列表，字典，集合，字符串都是可迭代的对象。 如何判断一个对象是否是可迭代的？ 12from collections import Iterableisinstance(要判断的对象，Iterable) 如果是可迭代的对象会返回一个True，否则返回False。 例如： 123456In [5]: from collections import IterableIn [6]: a &#x3D; [11,22,33]In [7]: isinstance(a, Iterable)Out[7]: True 如果想要一个类也变成一个可迭代对象，那么可以在类中添加一个__iter__方法。 例如： 1234567891011121314151617from collections import Iterableclass Classmate(object): &quot;&quot;&quot;docstring for ClassName&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name)classmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable)) 运行这个程序： 1234D:\\&gt;python test05.pytest05.py:1: DeprecationWarning: Using or importing the ABCs from &#39;collections&#39; instead of from &#39;collections.abc&#39; is deprecated since Python 3.3,and in 3.9 it will stop working from collections import Iterable判断classmate是否是可迭代对象： False 提示了collections的用法变了，所以修改一下程序：from collections.abc import Iterable再次执行： 12D:\\&gt;python test05.py判断classmate是否是可迭代对象： False 这时候给类添加一个__iter__方法： 1234567891011121314151617181920from collections.abc import Iterableclass Classmate(object): &quot;&quot;&quot;docstring for ClassName&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name) def __iter__(self): passclassmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable)) 运行一下： 12D:\\&gt;python test05.py判断classmate是否是可迭代对象： True 即使是没有具体实现，只要有这个魔法函数，这个类的实例对象也是可迭代对象。 这时候就满足了最基本的for循环条件，但是这时候还用不了。这是因为for循环的时候，每次要取一个值，还需要一个东西来记录取到了哪。 所以__iter__方法必须返回一个对象的引用，这个对象必须要有__iter__和__next__方法，这个对象就是一个迭代器。 判断一个对象是否是迭代器： 这时候导入的是collections下的Iterator 使用iter(对象)方法可以自动调用对象的__iter__方法1234567891011121314151617181920212223242526272829303132from collections.abc import Iterablefrom collections.abc import Iteratorclass Classmate(object): &quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name) def __iter__(self): return ClassIterator()class ClassIterator(object): &quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot; def __iter__(self): pass def __next__(self): passclassmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))# 因为&#96;__iter__&#96;方法返回的是ClassIterator()的引用，所以&#96;iter()&#96;方法得到的也是ClassIterator()的引用。classmate_iterator &#x3D; iter(classmate)print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator)) 运行程序：123D:\\&gt;python test05.py判断classmate是否是可迭代对象： True判断classmate是否是迭代器： True for循环每次调用的是这个对象的__iter__方法返回的另一个对象的引用的__next__方法。 所以如果使用for循环这个Classmate对象，每次取到的是Classmate对象的__iter__函数返回的ClassIterator对象的引用的__next__方法返回的值。 也就是如果把__next__的pass改为return 11的话，for循环每次返回的都应该是11。 修改代码如下： 12345678910111213141516171819202122232425262728293031323334from collections.abc import Iterablefrom collections.abc import Iteratorclass Classmate(object): &quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name) def __iter__(self): return ClassIterator()class ClassIterator(object): &quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot; def __iter__(self): pass def __next__(self): return 11classmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)# print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))# classmate_iterator &#x3D; iter(classmate)# print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))for name in classmate: print(name) 运行程序： 123456D:\\&gt;python test05.py1111111111 打印11无限循环。 但是实际上，希望ClassIterator实现的功能是把Classmate的name列表逐个取到，那么就可以在Classmate的__iter__函数返回ClassIterator引用的时候，把Classmate传过去。这样ClassIterator就可以取到name这一个列表。 修改代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940import timefrom collections.abc import Iterablefrom collections.abc import Iteratorclass Classmate(object): &quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name) def __iter__(self): return ClassIterator(self)class ClassIterator(object): &quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot; def __init__(self, obj): self.obj &#x3D; obj def __iter__(self): pass def __next__(self): return self.obj.name[0]classmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)# print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))# classmate_iterator &#x3D; iter(classmate)# print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))for name in classmate: print(name) time.sleep(1) 这时候ClassIterator类可以取到Classmate的name列表。但是每次取到的都是name[0]，想要继续往下取，就需要一个下标，每次取完一次，下标就加一。 修改代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timefrom collections.abc import Iterablefrom collections.abc import Iteratorclass Classmate(object): &quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name) def __iter__(self): return ClassIterator(self)class ClassIterator(object): &quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot; def __init__(self, obj): self.obj &#x3D; obj self.cur_index &#x3D; 0 def __iter__(self): pass def __next__(self): # 防止下标越界 if self.cur_index &lt; len(self.obj.name): res &#x3D; self.obj.name[self.cur_index] self.cur_index +&#x3D; 1 return resclassmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)# print(&quot;判断classmate是否是可迭代对象：&quot;, isinstance(classmate,Iterable))# classmate_iterator &#x3D; iter(classmate)# print(&quot;判断classmate是否是迭代器：&quot;,isinstance(classmate_iterator,Iterator))for name in classmate: print(name) time.sleep(1) 运行代码： 123456789D:\\&gt;python test05.py同学一同学二同学三NoneNoneNoneNoneNone 这时候会发生一种情况就是，当for已经取完name列表中的所有元素之后，并不会停止，会继续取name的值，但是因为当前的下标已经等于或超过name列表的长度，所以__next__方法没有返回任何值，所以for循环继续，但是每次取到的值都是None。 所以如果想让for循环结束，需要抛出一个StopIteration异常，for就会结束循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243import timefrom collections.abc import Iterablefrom collections.abc import Iteratorclass Classmate(object): &quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() def add(self, name): self.name.append(name) def __iter__(self): return ClassIterator(self)class ClassIterator(object): &quot;&quot;&quot;docstring for ClassIterator&quot;&quot;&quot; def __init__(self, obj): self.obj &#x3D; obj self.cur_index &#x3D; 0 def __iter__(self): pass def __next__(self): if self.cur_index &lt; len(self.obj.name): res &#x3D; self.obj.name[self.cur_index] self.cur_index +&#x3D; 1 return res else: raise StopIterationclassmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)for name in classmate: print(name) time.sleep(1) 运行代码： 1234D:\\&gt;python test05.py同学一同学二同学三 那么Classmate的__iter__可不可以返回自身，这样就不用返回别的类的引用。 修改代码如下： 123456789101112131415161718192021222324252627282930313233343536import timefrom collections.abc import Iterablefrom collections.abc import Iteratorclass Classmate(object): &quot;&quot;&quot;docstring for Classmate&quot;&quot;&quot; def __init__(self): self.name &#x3D; list() self.cur_index &#x3D; 0 def add(self, name): self.name.append(name) def __iter__(self): return self def __next__(self): if self.cur_index &lt; len(self.name): res &#x3D; self.name[self.cur_index] self.cur_index +&#x3D; 1 return res else: raise StopIterationclassmate &#x3D; Classmate()classmate.add(&quot;同学一&quot;)classmate.add(&quot;同学二&quot;)classmate.add(&quot;同学三&quot;)for name in classmate: print(name) time.sleep(1) 执行代码： 1234D:\\&gt;python test05.py同学一同学二同学三 总结： 如果一个对象是迭代器，那么它一定可以迭代。因为它一定包含__iter__和__next__。 一个对象可迭代，它不一定是迭代器。2.生成器生成器是一种特殊的迭代器。#####（1）创建生成器的方式 方法1： 1nums &#x3D; [x*2 for i in range(10)] nums会得到一个列表，如果把中括号变为小括号，nums得到的就是一个生成器。 12345678910111213141516171819202122232425262728293031323334353637In [11]: nums &#x3D; [ x*2 for x in range(10)]In [12]: numsOut[12]: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]In [13]: nums2 &#x3D; (x*2 for x in range(10))In [14]: nums2Out[14]: &lt;generator object &lt;genexpr&gt; at 0x0000015761EE6DC8&gt;In [15]: for i in nums: ...: print(i) ...:024681012141618In [16]: for i in nums2: ...: print(i) ...:024681012141618 生成器和列表都可以用for遍历。方法2： 把函数变为生成器。 只要函数里有yield，那么这个函数就会变成生成器。 如果想得到斐波那契数列的前多少位，可以这样来实现： 123456789def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: print(a) a , b &#x3D; b, a+b cur +&#x3D; 1worker(10) 运行程序： 1234567891011D:\\&gt;python test06.py0112358132134 如果把print改为yield，那么这个函数就变成了一个生成器。调用这个生成器的方式和原来调用函数的方式不同。如果这时候还使用worker(10)的方式，不是在调用函数，而是在创建一个生成器对象。在使用for循环遍历这个生成器对象，就可以每次取到一个值。 12345678910111213def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: # print(a) yield a a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(10)for i in obj: print(i) 执行代码： 1234567891011D:\\&gt;python test06.py0112358132134 for从obj里逐个取值的时候，第一次从worker的开始执行，执行到yield把a的值返回，然后第二次for再取值的时候，不是从worker的头开始执行，而是从上一次yield停止的位置继续往下执行。 如果每次只想取一个值打印出来，可以使用next： 12345678910111213141516171819202122def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: # print(a) yield a a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(10)res &#x3D; next(obj)print(res)res &#x3D; next(obj)print(res)res &#x3D; next(obj)print(res)res &#x3D; next(obj)print(res) next会取到当前yield后面的值，然后下次调用再取下一个值。 12345D:\\&gt;python test06.py0112 也就是想让生成器执行，要使用next让他执行，而不是调用生成器。 如果创建的是多个生成器： 123456789101112131415161718192021222324def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: # print(a) yield a a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(10)res &#x3D; next(obj)print(res)res &#x3D; next(obj)print(res)obj2 &#x3D; worker(10)res &#x3D; next(obj2)print(res)res &#x3D; next(obj2)print(res) 运行一下： 12345D:\\&gt;python test06.py0101 两个生成器对象之间互相没有影响。 生成器的结束还是使用异常让生成器结束遍历。 12345678910111213141516def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: # print(a) yield a a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(2)while True: try: print(next(obj)) except Exception as res: break 运行程序： 123D:\\&gt;python test06.py01 如果这个生成器有返回值，可以用下面的方式得到它的返回值： 123456789101112131415161718def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: # print(a) yield a a , b &#x3D; b, a+b cur +&#x3D; 1 return &quot;OK!&quot;obj &#x3D; worker(10)while True: try: print(next(obj)) except Exception as res: print(res.value) break 运行程序： 123456789101112D:\\&gt;python test06.py0112358132134OK! 生成器的启动还可以用send用法：生成器对象.sen(参数) 程序： 12345678910111213def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: res &#x3D; yield a print(res) a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(10)print(next(obj))print(obj.send(&quot;haha&quot;)) 运行结果： 1234D:\\&gt;python test06.py0haha1 执行过程：当用next启动生成器的时候，从worker的头开始执行，执行到yield a把a的值返回，然后打印出来。当send启动生成器的时候，系统从上一次yield的位置接着往下执行，执行到的第一条语句是把yield a 的值赋给res，yield a的值就是send中传递的参数，这时候res = “haha”，然后程序继续往下执行，打印出这个res。 send与next相比，优点就是可以传递参数。 send如果传递了参数不能一开始就调用，调用，会出错： 123456789101112def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: res &#x3D; yield a print(res) a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(10)print(obj.send(&quot;haha&quot;)) 结果： 12345D:\\&gt;python test06.pyTraceback (most recent call last): File &quot;test06.py&quot;, line 12, in &lt;module&gt; print(obj.send(&quot;haha&quot;))TypeError: can&#39;t send non-None value to a just-started generator 如果没有参数： 123456789101112def worker(tmp): a, b &#x3D; 0, 1 cur &#x3D; 0 while cur &lt; tmp: res &#x3D; yield a print(res) a , b &#x3D; b, a+b cur +&#x3D; 1obj &#x3D; worker(10)print(obj.send(None)) 运行： 12D:\\&gt;python test06.py0 #####（2）使用yield实现多任务（协程实现多任务）只要在函数里面写上yield，函数就变成了一个生成器，再创建生成器对象，调用next即可。 代码： 1234567891011121314151617181920212223import timedef task01(): while True: print(&quot;task01&quot;) time.sleep(1) yielddef task02(): while True: print(&quot;task02&quot;) time.sleep(1) yielddef main(): t1 &#x3D; task01() t2 &#x3D; task02() while True: next(t1) next(t2)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 结果： 12345678910111213D:\\&gt;python test07.pytask01task02task01task02task01task02task01task02task01task02task01task02 这是一个协程的并发（假的“一起”执行）。#####（3）使用greenlet、gevent实现多任务（协程实现多任务）使用greenlet可以替换yield。 要使用greenlet需要导入：from greenlet import greenlet例如： 12345678910111213141516171819202122from greenlet import greenletimport timedef test1(): while True: print(&quot;test1&quot;) # 切换到gr2去执行 gr2.switch() time.sleep(0.5)def test2(): while True: print(&quot;test2&quot;) # 切换到gr1去执行 gr1.switch() time.sleep(0.5)# 返回值是一个greenlet对象gr1 &#x3D; greenlet(test1)gr2 &#x3D; greenlet(test2)gr1.switch() 运行结果： 1234567D:\\&gt;python test07.pytest1test2test1test2test1test2 greenlet的切换是在单线程内切换，而如果想要切换到其他的协程，真正实现多任务，就需要用到gevent。 gevent也需要导入：import gevent例如： 123456789101112131415import geventimport timedef test(n): for i in range(n): print(gevent.getcurrent(), i)# 指定去哪执行g1 &#x3D; gevent.spawn(test, 5)g2 &#x3D; gevent.spawn(test, 5)g3 &#x3D; gevent.spawn(test, 5)g1.join()g2.join()g3.join() 运行： 12345678910111213141516D:\\&gt;python test07.py&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 0&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 1&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 2&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 3&lt;Greenlet at 0x158e64a3e18: test(5)&gt; 4&lt;Greenlet at 0x158e6514048: test(5)&gt; 0&lt;Greenlet at 0x158e6514048: test(5)&gt; 1&lt;Greenlet at 0x158e6514048: test(5)&gt; 2&lt;Greenlet at 0x158e6514048: test(5)&gt; 3&lt;Greenlet at 0x158e6514048: test(5)&gt; 4&lt;Greenlet at 0x158e6514378: test(5)&gt; 0&lt;Greenlet at 0x158e6514378: test(5)&gt; 1&lt;Greenlet at 0x158e6514378: test(5)&gt; 2&lt;Greenlet at 0x158e6514378: test(5)&gt; 3&lt;Greenlet at 0x158e6514378: test(5)&gt; 4 在greenlet中，遇到延时，程序会等待这个延时结束，再去切换另一个任务，而gevent遇到延时就会自动切换。 例如： 123456789101112131415161718192021222324import geventdef test01(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.5)def test02(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.5)def test03(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.5)g1 &#x3D; gevent.spawn(test01, 5)g2 &#x3D; gevent.spawn(test02, 5)g3 &#x3D; gevent.spawn(test03, 5)g1.join()g2.join()g3.join() 运行： 12345678910111213141516D:\\&gt;python test07.py&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 0&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 0&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 0&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 1&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 1&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 1&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 2&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 2&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 2&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 3&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 3&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 3&lt;Greenlet at 0x255d7d63e18: test01(5)&gt; 4&lt;Greenlet at 0x255d7dd4048: test02(5)&gt; 4&lt;Greenlet at 0x255d7dd4378: test03(5)&gt; 4 如果是三个协程执行的是同一份代码： 1234567891011121314import geventdef test01(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.5)g1 &#x3D; gevent.spawn(test01, 5)g2 &#x3D; gevent.spawn(test01, 5)g3 &#x3D; gevent.spawn(test01, 5)g1.join()g2.join()g3.join() 运行： 12345678910111213141516D:\\&gt;python test07.py&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 0&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 0&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 0&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 1&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 1&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 1&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 2&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 2&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 2&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 3&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 3&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 3&lt;Greenlet at 0x19a8ef33e18: test01(5)&gt; 4&lt;Greenlet at 0x19a8efa4048: test01(5)&gt; 4&lt;Greenlet at 0x19a8efa4378: test01(5)&gt; 4 先打印了每个协程的0，然后打印了1、2、3、4。 所以gevent在有延迟的时候，自动切换了。 协程依赖与线程，线程依赖于线程。 进程、线程、协程对比 进程是资源分配的基本单位，多进程耗费资源最多。 多线程的程序，同一时间只有一个线程在运行。 在不考虑GIL的前提下，优先考虑线程，再考虑协程，再考虑进程。 协程利用进程在等待的时间去做别的事情，协程切换资源消耗小，效率高。 进程最稳定。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"深入浅出Python深拷贝浅拷贝","slug":"深入浅出Python深拷贝浅拷贝","date":"2020-08-11T01:42:15.000Z","updated":"2020-08-11T09:38:34.810Z","comments":true,"path":"2020/08/11/深入浅出Python深拷贝浅拷贝/","link":"","permalink":"http://yoursite.com/2020/08/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPython%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"所谓拷贝，就是复制。 深拷贝，就是复制的比较多，浅拷贝，就是复制的比较少。","text":"所谓拷贝，就是复制。 深拷贝，就是复制的比较多，浅拷贝，就是复制的比较少。 在Python中，copy.copy可以完成浅拷贝，copy.deepcopy可以完成深拷贝。 举例 图解1.赋值如果 a = [11,22]， 把a赋给b： 12345678In [1]: a &#x3D; [11, 22]In [2]: b &#x3D; aIn [3]: aOut[3]: [11, 22]In [4]: bOut[4]: [11, 22] 从结果来看是看不出来a和b是否是同一个，我们用id()函数查看一下a和b的id： 12345In [5]: id(a)Out[5]: 2293026594376In [6]: id(b)Out[6]: 2293026594376 a 和 b的id相同，说明他们指向了同一块区域，这里说指向，是因为在Python中，实际上是有一个空间存储了[11, 22]，在给a赋值的时候，变量名a就指向了[11,22]的空间，当把a赋给b的时候，实际上是让b也指向[11,22]。 画图来说明是这样的： 2.浅拷贝在python中，copy.copy()可以用来浅拷贝，copy.deepcopy()可以用来深拷贝。 重新定义了a，b，然后把a和b作为一个列表赋给c。 12345In [11]: a &#x3D; [11,22]In [12]: b &#x3D; [33,44]In [13]: c &#x3D; [a, b] 这时候相当于：验证一下： 如果a与c[0]的id相同，就说明他们指向的是相同的区域。 12345In [14]: id(a)Out[14]: 2293027197896In [15]: id(c[0])Out[15]: 2293027197896 如果现在把c赋给d： 1In [16]: d &#x3D; c 这相当于： 验证一下： 12345In [17]: id(d)Out[17]: 2293026531656In [18]: id(c)Out[18]: 2293026531656 如果这时候把c浅拷贝给e： 123In [19]: import copyIn [20]: e &#x3D; copy.copy(c) 这时候，e会指向一块新开辟的区域。 因为是浅拷贝，所以e的这块区域也会指向c的区域的指向，也就是这样： 验证： 1234567891011In [21]: id(e)Out[21]: 2293027309192In [22]: id(c)Out[22]: 2293026531656In [23]: id(e[0])Out[23]: 2293027197896In [24]: id(c[0])Out[24]: 2293027197896 e和c的地址不同，说明e和c指向的区域不一样，e[0]和c[0]的id相同，说明他们指向了同一块空间。 这就是浅拷贝，它只拷贝了第一层，第二层以下的数据并没有真的“拷贝”出来。 当前的a，b和c，e： 1234567891011In [25]: aOut[25]: [11, 22]In [26]: bOut[26]: [33, 44]In [27]: cOut[27]: [[11, 22], [33, 44]]In [28]: eOut[28]: [[11, 22], [33, 44]] 因为是浅拷贝，所以如果a修改了，e也会修改。 12345678In [30]: aOut[30]: [11, 22, &#39;hahaha&#39;]In [31]: cOut[31]: [[11, 22, &#39;hahaha&#39;], [33, 44]]In [32]: eOut[32]: [[11, 22, &#39;hahaha&#39;], [33, 44]] a = [11,22] c = [a,b]，再来看看深拷贝。 3.深拷贝如果是深拷贝，就原原本本的把所有层的数据都拷贝一份新的，指向也指向这份新的数据。 1234567In [44]: f &#x3D; copy.deepcopy(c)In [45]: cOut[45]: [[11, 22], [33, 44]]In [46]: fOut[46]: [[11, 22], [33, 44]] 这时候的指向是这样的： 验证：如果c和f，c[0]和f[0]的地址不同，说明是这样的。 1234567891011In [47]: id(c)Out[47]: 2293026784840In [48]: id(f)Out[48]: 2293027611400In [49]: id(c[0])Out[49]: 2293027354312In [50]: id(f[0])Out[50]: 2293027035208 4.总结所以不管是copy还是deepcopy，都会先创建一份新的空间，而直接赋值b=a则不会。 几个问题问题1前提如下： 123456789In [53]: a &#x3D; [11,22]In [54]: b &#x3D; [33,44]In [55]: c &#x3D; [a, b]In [56]: d &#x3D; copy.copy(c)In [57]: e &#x3D; copy.deepcopy(c) 如果这时候在c中append一个新的列表[55,66]d和e会如何变化？ 查看结果： 1234567In [58]: c.append([55,66])In [59]: dOut[59]: [[11, 22], [33, 44]]In [60]: eOut[60]: [[11, 22], [33, 44]] 原因图解如下：一开始的指向是这样的： 或者把d放在上面更直观一些： 这时候在c中添加新的列表： 实际上的这个添加和d和e是没有任何关系的，所以才会有这样的结果，因为d已经拷贝完了，拷贝完之后才添加的，所以d中不会有[55,66]。 问题2前提： 123In [70]: a &#x3D; (11,22)In [71]: b &#x3D; copy.copy(a) 把a浅拷贝给b，这时候a是一个元组。 来查看a和b的id： 12345In [73]: id(a)Out[73]: 2293027979080In [74]: id(b)Out[74]: 2293027979080 发现他们的地址是一样的。 所以如果浅拷贝发现拷贝对象是一个元组，就直接不拷贝了，变为了指向。 因为元组是不可变类型，数据不会被修改。 如果是深拷贝： 1In [75]: c &#x3D; copy.deepcopy(a) 这时候查看c的id和a的id： 12345In [76]: id(c)Out[76]: 2293027979080In [77]: id(a)Out[77]: 2293027979080 他们的地址相同，说明深拷贝也没有拷贝。 再看一种情况： 12345678910In [79]: a &#x3D; [11,22]In [80]: b &#x3D; [33,44]In [81]: c &#x3D; (a,b)In [82]: d &#x3D; copy.copy(c)In [83]: e &#x3D; copy.deepcopy(c) 此时a和b都是可变的列表，c是不可变的元组，d有了c的浅拷贝，e有了d的深拷贝。 这时候d和e有没有拷贝c？ 来查看一下id： 12345678In [84]: id(c)Out[84]: 2293028072520In [85]: id(d)Out[85]: 2293028072520In [86]: id(e)Out[86]: 2293027609416 说明浅拷贝还是没有拷贝，还是指向，但深拷贝拷贝了。所以： 如果拷贝的是一个元组（第一层是元组），而且元组中都是不可变对象，那么copy模块不管是深拷贝还是浅拷贝都变为了指向（引用）。 如果拷贝的是一个元组（第一层是元组），不管元组中的对象可变还是不可变，浅拷贝都直接指向，而不开辟新的空间了。 如果拷贝的是一个元组（第一层是元组），元组中有可变对象，那么深拷贝还是会开辟新的空间，把每一层的数据都拷贝了。 所以当深拷贝的时候，如果每一层的元素都是不可变对象，那深拷贝也不拷贝了，变为了指向，但是不管哪一层的数据，只要有一个是可变对象，那么深拷贝就会递归的把所有的数据都拷贝一份。 问题3切片是浅拷贝。 123456789101112131415161718192021222324In [88]: a &#x3D; [11,22]In [89]: b &#x3D; [33,44]In [90]: c &#x3D; [a,b]In [91]: d &#x3D; c[:]In [92]: id(c)Out[92]: 2293027355592In [93]: id(d)Out[93]: 2293026561416In [94]: a.append(&quot;lalala&quot;)In [95]: aOut[95]: [11, 22, &#39;lalala&#39;]In [96]: cOut[96]: [[11, 22, &#39;lalala&#39;], [33, 44]]In [97]: dOut[97]: [[11, 22, &#39;lalala&#39;], [33, 44]] 问题4字典中的拷贝。字典有一个copy方法，用法如下： 1dict.copy() 这个拷贝是一个浅拷贝。 123In [100]: first &#x3D; &#123;&quot;a&quot;:[1,2],&quot;b&quot;:33&#125;In [101]: second &#x3D; first.copy() 查看一下两个字典： 12345In [102]: firstOut[102]: &#123;&#39;a&#39;: [1, 2], &#39;b&#39;: 33&#125;In [103]: secondOut[103]: &#123;&#39;a&#39;: [1, 2], &#39;b&#39;: 33&#125; 如果这时候[11,22]列表中添加一个新的值3，再查看一下： 1234567In [104]: first[&#39;a&#39;].append(3)In [105]: firstOut[105]: &#123;&#39;a&#39;: [1, 2, 3], &#39;b&#39;: 33&#125;In [106]: secondOut[106]: &#123;&#39;a&#39;: [1, 2, 3], &#39;b&#39;: 33&#125; 说明是浅拷贝。 补充说明： 字典的key是保存在字典里的，value才是指向。 补充说明：在python中，像11这样的值的类型的数据在只会创建一个，所以如果a=[11,22],b=[11,22]，实际指向是这样的： 所以图解的部分画的图并不准确，可以重新看一下~ 补充部分可以参考：https://www.cnblogs.com/shiyublog/p/10809953.html#_label3","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"一天两道算法题(中等)(6)(Leetcode 200 695)","slug":"一天两道算法题(中等)(6)","date":"2020-08-06T11:40:33.000Z","updated":"2020-08-11T03:53:19.130Z","comments":true,"path":"2020/08/06/一天两道算法题(中等)(6)/","link":"","permalink":"http://yoursite.com/2020/08/06/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(6)/","excerpt":"200. 岛屿数量 每当遇到一个“1”，也就是遇到一个岛屿，就把统计岛屿数量的res+1，然后把这个点变为“0”，再遍历这个点相连的所有的1，把这些1都变为0，这样下次再遇到这个岛屿的点就不用再遍历了。","text":"200. 岛屿数量 每当遇到一个“1”，也就是遇到一个岛屿，就把统计岛屿数量的res+1，然后把这个点变为“0”，再遍历这个点相连的所有的1，把这些1都变为0，这样下次再遇到这个岛屿的点就不用再遍历了。 这是整体实现的一个想法，具体如下： 遍历这个grid，如果遇到“1”，也就是遇到了岛屿，就把结果res加一，把当前的“1”置为“0”，再把当前的下标放到cur列表中 遍历cur，每次把它的第一个节点pop出来，这样我们得到了一个坐标，遍历这个坐标的上下左右，如果上下左右没有越界，而且上下左右有为“1”的，把坐标append到cur中，把“1”置为“0” 这样当cur遍历结束后，当前岛屿所有的“1”都被置为了“0” 注意：grid中的所有元素都是字符，不是数字。代码： 123456789101112131415161718class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: res = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \"1\": cur = [(i, j)] grid[i][j] = \"0\" res += 1 while cur: m,n = cur.pop(0) for x, y in [(1,0),(0,1),(0,-1),(-1,0)]: tmp_i = x + m tmp_j = y + n if tmp_i &gt;= 0 and tmp_i &lt; len(grid) and tmp_j &gt;= 0 and tmp_j &lt; len(grid[0]) and grid[tmp_i][tmp_j] == \"1\": cur.append((tmp_i,tmp_j)) grid[tmp_i][tmp_j] = \"0\" return res 695. 岛屿的最大面积 这道题比起上一道题只是维护的res不同，这一道维护的res是岛屿的面积而不是数量了。 用tmp来记录当前岛屿的面积，遍历完当前岛屿之后，将当前岛屿的面积tmp和res中较大的那个赋给res代码：123456789101112131415161718192021class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: res = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: cur = [(i,j)] grid[i][j] = 0 tmp = 1 while cur: i,j = cur.pop(0) for x,y in [(0,1),(1,0),(-1,0),(0,-1)]: tmp_i = i + x tmp_j = j + y if tmp_i &gt;= 0 and tmp_i &lt; len(grid) and tmp_j &gt;= 0 and tmp_j &lt; len(grid[0]): if grid[tmp_i][tmp_j] == 1: cur.append((tmp_i,tmp_j)) tmp += 1 grid[tmp_i][tmp_j] = 0 res = max(res, tmp) return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一天两道算法题(中等)(5)(Leetcode 15 18)","slug":"一天两道算法题(中等)(5)","date":"2020-08-05T11:40:33.000Z","updated":"2020-08-11T03:53:19.211Z","comments":true,"path":"2020/08/05/一天两道算法题(中等)(5)/","link":"","permalink":"http://yoursite.com/2020/08/05/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(5)/","excerpt":"15. 三数之和 把数组先排序，然后遍历这个数组 因为数组已经排好序，所以遍每当遍历到一个新的元素，可以排除几种情况 如果当前的数是nums[i]，如果nums[i]+nums[i+1]+nums[i+2]的值都比0大，说明后面的元素已经不可能有三个数的和等于0了，可以break掉循环 如果当前的数加上排好序数组的倒数第一个和倒数第二个数的值的和比0还小，也就是当前的值加上数组中最大的两个值还小于0，那么直接continue，遍历下一个值 如果当前的下标大于0，而且nums[i] == nums[i - 1]，也就是当前的数等于它前一个数，那么也之间continue不找这个数的组合了，因为结果集中要求没有重复的三原组","text":"15. 三数之和 把数组先排序，然后遍历这个数组 因为数组已经排好序，所以遍每当遍历到一个新的元素，可以排除几种情况 如果当前的数是nums[i]，如果nums[i]+nums[i+1]+nums[i+2]的值都比0大，说明后面的元素已经不可能有三个数的和等于0了，可以break掉循环 如果当前的数加上排好序数组的倒数第一个和倒数第二个数的值的和比0还小，也就是当前的值加上数组中最大的两个值还小于0，那么直接continue，遍历下一个值 如果当前的下标大于0，而且nums[i] == nums[i - 1]，也就是当前的数等于它前一个数，那么也之间continue不找这个数的组合了，因为结果集中要求没有重复的三原组 然后设置两个下标值，一个left，一个right，让left从i的下一个值开始往后遍历，让right从数组的末尾开始往前遍历 计算当前的tmp值，tmp = nums[i]+nums[left]+nums[right] 如果当前的tmp比0大，说明right找大了，把right-1 如果当前的tmp比0小，说明left找小了，把left+1 如果当前的tmp为0，说明当前是一个结果，把[nums[i],nums[left],nums[right]]这个列表append到结果集中（结果集res = []） 如果当前的left &lt; right，那么继续找不同的left和right 这时候要做一件事情是去重，找到第一个不和刚才的right值相同的right 找到第一个不和刚才的left的值相同的left 这一块看代码的时候要注意一下 最后返回结果集代码：1234567891011121314151617181920212223242526272829303132class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] # 因为要给left和right留位置，所以只遍历到len(nums)-2的位置 for i in range(len(nums) - 2): if nums[i] + nums[len(nums) - 1] + nums[len(nums) - 2] &lt; 0: continue if nums[i] + nums[i + 1] + nums[i + 2] &gt; 0: return res if i &gt; 0 and nums[i] == nums[i - 1]: continue left = i + 1 right = len(nums) - 1 while left &lt; right: tmp = nums[i] + nums[left] + nums[right] if tmp == 0: res.append([nums[i], nums[left], nums[right]]) # left如果和left-1的值不同，说明当前的left已经和之前的值不一样了 # 但是right因为边界的问题，与之进行比较的right-1，所以当right的值和right-1的值不同时，right当前的值是最后一个与之前right相等的值 while left &lt; right and nums[left] == nums[left - 1]: left += 1 while left &lt; right and nums[right] == nums[right - 1]: right -= 1 # 所以到这里right还要-1 # 这里说的left的值和right的值等价于nums[left]和nums[right] right -= 1 elif tmp &gt; 0: right -= 1 else: left += 1 return res 18. 四数之和 总体上和三数之和的思路差不多 代码： 123456789101112131415161718192021222324252627282930313233class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: nums.sort() res = [] # 第一个区别是遍历到len(nums)-3就结束了 for i in range(len(nums) - 3): if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target: return res if nums[i] + nums[len(nums) - 1] + nums[len(nums) - 2] + nums[len(nums) - 3] &lt; target: continue if i &gt; 0 and nums[i] == nums[i - 1]: continue # 第二个是这里嵌套了循环，上面的循环是用来找第一个数，下面的循环用来找第二个和第三个数 for j in range(i + 1, len(nums) - 2): # 这里有一个需要去重的地方，注意是j &gt; i + 1 if j &gt; i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = len(nums) - 1 while left &lt; right: tmp = nums[i] + nums[j] + nums[left] + nums[right] if tmp == target: res.append([nums[i], nums[j], nums[left], nums[right]]) while left &lt; right and nums[left] == nums[left + 1]: left += 1 while left &lt; right and nums[right] == nums[right - 1]: right -= 1 right -= 1 elif tmp &gt; target: right -= 1 else: left += 1 return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一天两道算法题(中等)(4)(Leetcode 46 47)","slug":"一天两道算法题(中等)(4)","date":"2020-08-04T11:40:33.000Z","updated":"2020-08-11T03:53:19.170Z","comments":true,"path":"2020/08/04/一天两道算法题(中等)(4)/","link":"","permalink":"http://yoursite.com/2020/08/04/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(4)/","excerpt":"46. 全排列 和之前的所有本系列的题的解法一致~","text":"46. 全排列 和之前的所有本系列的题的解法一致~ 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 回溯法： 代码： 123456789101112131415class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: if not nums: return [] return self.helper(nums, [], [], len(nums)) def helper(self, nums, tmp, res, n): if len(tmp) == n: res.append(copy.deepcopy(tmp)) return res for i in range(len(nums)): tmp.append(nums[i]) self.helper(nums[:i]+nums[i+1:], tmp, res, n) tmp.pop() return res 47. 全排列 II 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 代码： 12345678910111213141516171819class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: if not nums: return [] nums.sort() return self.helper(nums, [], [], len(nums)) def helper(self, nums, res, tmp, n): if len(tmp) == n: res.append(copy.deepcopy(tmp)) return res for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i - 1]: continue tmp.append(nums[i]) self.helper(nums[:i] + nums[i+1:], res, tmp, n) tmp.pop() return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一天两道算法题(中等)(3)(Leetcode 78 90)","slug":"一天两道算法题(中等)(3)","date":"2020-08-03T11:40:33.000Z","updated":"2020-08-11T03:53:19.106Z","comments":true,"path":"2020/08/03/一天两道算法题(中等)(3)/","link":"","permalink":"http://yoursite.com/2020/08/03/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(3)/","excerpt":"78. 子集难度：中等","text":"78. 子集难度：中等 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums &#x3D; [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 初始化res数组作为返回的结果集，初始化为[[]]，也就是第一个返回的结果为空数组。 然后遍历整数数组nums，每遍历到一个值，就把res中所有的结果加上这个当前的数组值，然后把这些所有的可能加到res中 例如遍历到1，当前res中只有一个空数组，那么把空数组+[1]，作为一个结果append到res中，这时res为[[],[1]] 遍历到2，当前res为[[],[1]]，把res中的所有可能加上[2]，就得到[2],[1,2]，把这些结果加到res中，res变为[[],[1],[2],[1,2]] 代码： 12345678class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res &#x3D; [[]] for i in nums: # res[:]复制了一份副本 for subset in res[:]: res.append(subset + [i]) return res 回溯法：和组合总和系列的题解法一样~ 123456789101112131415class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: if not nums: return [] return self.helper(nums, [], []) def helper(self, nums, tmp, res): res.append(copy.deepcopy(tmp)) if not nums: return res for i in range(len(nums)): tmp.append(nums[i]) self.helper(nums[i+1:], tmp, res) tmp.pop() return res 90. 子集 II给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 回溯法： 123456789101112131415161718class Solution: def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() if not nums: return [] return self.helper(nums, [], []) def helper(self, nums, tmp, res): res.append(copy.deepcopy(tmp)) if not nums: return res for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i - 1]: continue tmp.append(nums[i]) self.helper(nums[i+1:], tmp, res) tmp.pop() return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一天两道算法题(中等)(2)(Leetcode 216 77)","slug":"一天两道算法题(中等)(2)","date":"2020-08-02T11:42:05.000Z","updated":"2020-08-11T03:53:19.038Z","comments":true,"path":"2020/08/02/一天两道算法题(中等)(2)/","link":"","permalink":"http://yoursite.com/2020/08/02/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(2)/","excerpt":"216. 组合总和 III找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。","text":"216. 组合总和 III找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 12输入: k &#x3D; 3, n &#x3D; 7输出: [[1,2,4]] 示例 2: 12输入: k &#x3D; 3, n &#x3D; 9输出: [[1,2,6], [1,3,5], [2,3,4]] 这道题和组合总和1、2差不多，只不过不再遍历数组，而是一个数字范围。 1234567891011121314151617class Solution: def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: if k &#x3D;&#x3D; 0: return [] return self.helper(1, [], [], k, n) def helper(self, num, tmp, res, k, n): if k &#x3D;&#x3D; 0 and n &#x3D;&#x3D; 0: res.append(copy.deepcopy(tmp)) return res for i in range(num, 10): if i &lt;&#x3D; n: tmp.append(i) self.helper(i+1, tmp, res, k-1, n - i) tmp.pop() return res 77. 组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。示例: 12345678910输入: n &#x3D; 4, k &#x3D; 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 相同思路12345678910111213141516class Solution: def combine(self, n: int, k: int) -&gt; List[List[int]]: if k &#x3D;&#x3D; 0: return [] return self.helper(k, [], [], n, 1) def helper(self, k, tmp, res, n, i): if len(tmp) &#x3D;&#x3D; k: res.append(copy.deepcopy(tmp)) return res for i in range(i, n+1): if i &lt;&#x3D; n: tmp.append(i) self.helper(k, tmp, res, n, i+1) tmp.pop() return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一天两道算法题(中等)(1)(Leetcode 39 40)","slug":"一天两道算法题(中等)(1)","date":"2020-08-01T01:42:15.000Z","updated":"2020-08-11T03:53:19.228Z","comments":true,"path":"2020/08/01/一天两道算法题(中等)(1)/","link":"","permalink":"http://yoursite.com/2020/08/01/%E4%B8%80%E5%A4%A9%E4%B8%A4%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98(%E4%B8%AD%E7%AD%89)(1)/","excerpt":"Backtracking(回溯算法)：三步： 设置现场 DFS（递归） 回复现场（恢复现场）","text":"Backtracking(回溯算法)：三步： 设置现场 DFS（递归） 回复现场（恢复现场） 39. 组合总和 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 123456输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,所求解集为：[ [7], [2,2,3]] 示例 2： 1234567输入：candidates &#x3D; [2,3,5], target &#x3D; 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 先实现这个递归，遍历给定的数组，如果遍历到当前元素比target大，直接遍历下一个元素，如果当前的元素值比target小或相等，那么就递归到下一层找第二个数 遍历给定的数组，如果当前元素&lt;=target，说明当前的元素有可能是结果中的一个，把当前这个元素放到临时的tmp列表中，然后遍历下一层 传递给下一层的值有candidates，因为需要继续遍历，但是传递给下一层的candidates不是完整的candidates，而是从当前元素开始的所有后面的candidates部分，因为如果遍历到3的时候，3为第一个元素，继续往下一层遍历是希望找到candidates3开始后面的元素是否有可能为结果的 传递给下一层的target要减去当前的candidates[i]，因为到下一层要判断target是否为0，如果为0说明当前的tmp就是一种结果，需要把tmp添加到res中 遍历后tmp需要pop掉这一层添加的节点是恢复现场，例如如果从头开始遍历，tmp为[]，target为7，遍历到第一层，tmp为[2],target为5，遍历到下一层,tmp为[2,2],target为3，继续下一层，tmp为[2,2,2],target为1，再遍历到下一层的时候第一个元素2已经大于target1了，所以直接返回，这时候返回到上一次，pop掉最后一个元素2,tmp变为[2,2]，当前的target为3，然后for循环遍历到3，因为3&lt;=target，所以tmp变为[2,2,3]，target传递给下一层为0，下一层会判断target为0，将tmp列表append到res中去 这里需要用到深拷贝，因为tmp在不断被修改，如果用浅拷贝，最后tmp会被修改为[]，这时候res中被append进的tmp也会变为[] 代码： 1234567891011121314151617class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: if not candidates: return [] return self.helper(candidates, [], [], target) def helper(self, candidates, tmp, res, target): if target &#x3D;&#x3D; 0: res.append(copy.deepcopy(tmp)) return res for i in range(len(candidates)): if candidates[i] &lt;&#x3D; target: tmp.append(candidates[i]) self.helper(candidates[i:], tmp, res,target - candidates[i]) tmp.pop() return res 40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,所求解集为:[ [1,2,2], [5]] 和组合1的区别： 一个是在向下传递的时候，因为不能用重复的数字，所以向下传递的candidates[i:]变为了candidates[i+1:] 另一个是遍历到当前层，如果当前的列表元素值和前一个元素值相等，那就不遍历当前元素的下一层了，因为所有的可能结果在遍历前一个相等元素的时候，都找过了。 代码：1234567891011121314151617181920class Solution: def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: if not candidates: return [] candidates.sort() return self.helper(candidates, [], [], target) def helper(self, candidates, tmp, res, target): if target &#x3D;&#x3D; 0: res.append(copy.deepcopy(tmp)) return res for i in range(len(candidates)): if i &gt; 0 and candidates[i] &#x3D;&#x3D; candidates[i - 1]: continue if candidates[i] &lt;&#x3D; target: tmp.append(candidates[i]) self.helper(candidates[i+1:], tmp, res, target-candidates[i]) tmp.pop() return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Anki2.1插件推荐","slug":"Anki插件推荐","date":"2020-06-01T11:40:33.000Z","updated":"2020-06-01T09:01:06.998Z","comments":true,"path":"2020/06/01/Anki插件推荐/","link":"","permalink":"http://yoursite.com/2020/06/01/Anki%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"插件首页https://ankiweb.net/shared/addons/2.1","text":"插件首页https://ankiweb.net/shared/addons/2.1 插件1 ReviewHeatmap下载地址：https://ankiweb.net/shared/info/723520343 插件代码：723520343 展示： 说明： 用颜色的深浅表示当天看了多少卡片，右上角的可以设置颜色和其他。 插件2 AwesomeTTS for Anki 2.1下载地址：https://ankiweb.net/shared/info/814349176 插件代码：814349176 展示： 说明： 可以插入单词读音。 插件3 Large and Colorful Buttons下载地址：https://ankiweb.net/shared/info/1829090218 插件代码：1829090218 展示： 说明： 比较大的按键。 插件4 Colorful toolbars下载地址：https://ankiweb.net/shared/info/388296573 插件代码：388296573 展示： 说明： 把首页文字的按键变成了图标。","categories":[{"name":"Others","slug":"Others","permalink":"http://yoursite.com/categories/Others/"}],"tags":[{"name":"Anki","slug":"Anki","permalink":"http://yoursite.com/tags/Anki/"}]},{"title":"解决Github访问慢的方法","slug":"解决Github访问慢的方法","date":"2020-05-14T00:43:03.000Z","updated":"2020-05-23T06:29:46.186Z","comments":true,"path":"2020/05/14/解决Github访问慢的方法/","link":"","permalink":"http://yoursite.com/2020/05/14/%E8%A7%A3%E5%86%B3Github%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"1.使用浏览器访问https://www.ipaddress.com/。在这个位置分别输入github.com和github.global.ssl.fastly.net","text":"1.使用浏览器访问https://www.ipaddress.com/。在这个位置分别输入github.com和github.global.ssl.fastly.net 搜索一下~找到github.com对应的ip： 找到github.global.ssl.fastly.net对应的ip： 每台电脑获取的ip应该不一样。我获取的是140.82.112.3和199.232.69.194。 2.Windows系统打开以下目录：C:\\Windows\\System32\\drivers\\etc用记事本打开host文件，把以下内容添加进去： 140.82.112.3 github.com199.232.69.194 github.global.ssl.fastly.Net 保存、关闭。 3.打开cmd用windows+R打开：输入cmd，回车。在小黑框里输入ipconfig /flushdns，更新DNS缓存。 4.再次访问Github快多啦！","categories":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]},{"title":"置顶","slug":"置顶","date":"2020-05-09T11:40:33.000Z","updated":"2020-08-11T08:02:23.269Z","comments":true,"path":"2020/05/09/置顶/","link":"","permalink":"http://yoursite.com/2020/05/09/%E7%BD%AE%E9%A1%B6/","excerpt":"","text":"博客搬迁中。。。源地址：https://www.jianshu.com/u/400aba58cff5","categories":[],"tags":[]},{"title":"C++运算符重载实现(加号、左移、递增、赋值、关系运算符、函数调用)","slug":"C++运算符重载实现(加号、左移、递增、赋值、关系运算符、函数调用)","date":"2020-05-06T11:40:33.000Z","updated":"2020-05-12T07:11:51.710Z","comments":true,"path":"2020/05/06/C++运算符重载实现(加号、左移、递增、赋值、关系运算符、函数调用)/","link":"","permalink":"http://yoursite.com/2020/05/06/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0(%E5%8A%A0%E5%8F%B7%E3%80%81%E5%B7%A6%E7%A7%BB%E3%80%81%E9%80%92%E5%A2%9E%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8)/","excerpt":"先来复习一下C++的内存分区问题~","text":"先来复习一下C++的内存分区问题~ C++内存分区C++程序的内存分区可划分为四大内存分区：堆、栈、全局/静态存储区和代码区。 不同类型的变量存放的区域不同。 在程序被编译为exe可执行文件后，未运行之前，分为两个区域：代码区和全局区。 代码区存放程序体的二进制代码。比如我们写的函数，都是在代码区的。 123456789101112int a &#x3D; 0;&#x2F;&#x2F;静态全局变量区char *p1; &#x2F;&#x2F;编译器默认初始化为NULLvoid main()&#123; int b; &#x2F;&#x2F;栈 char s[] &#x3D; &quot;abc&quot;;&#x2F;&#x2F;栈 char *p2 &#x3D; &quot;123456&quot;;&#x2F;&#x2F;123456在字符串常量区，p2在栈上 static int c &#x3D;0; &#x2F;&#x2F;c在静态变量区，0为文字常量，在代码区 const int d&#x3D;0; &#x2F;&#x2F;栈 static const int d;&#x2F;&#x2F;静态常量区 p1 &#x3D; (char *)malloc(10);&#x2F;&#x2F;分配得来得10字节在堆区。 strcpy(p1, &quot;123456&quot;); &#x2F;&#x2F;123456放在字符串常量区，编译器可能会将它与p2所指向的&quot;123456&quot;优化成一个地方 &#125; 以上所有代码，编译成二进制后存放于代码区，文字常量存放于代码区，是不可寻址的。 全局区全局区存储全局变量，静态变量，还包括了常量区，字符串常量和其他常量（const修饰的全局变量）也存放在全局区。全局区的数据在程序结束后由操作系统释放。 程序运行之后 栈区由编译器自动释放，存放函数的参数值，局部变量等。整个程序的栈区的大小可以在编译器中由用户自行设定。 注意：不要返回局部变量地址。 堆区由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用new进行堆的申请，堆的总大小为机器的虚拟内存的大小。new返回的是该数据类型的指针。 1int * p &#x3D; new int(10); 使用delete进行释放。 重载方式有两种：1.重载的函数作为成员函数。2.重载的函数作为全局函数函数名是规定的：operator+ 加号运算符（“+”）重载对于内置的数据类型，编译器知道如何进行运算。两个自定义的数据类型，进行相加，就需要进行加号运算符重载。 成员函数实现加号重载： 12345678910111213141516171819202122232425class Person&#123;public: Person operator+(Person &amp;p)&#123; Person tmp; tmp.a &#x3D; this-&gt;a + p.a; tmp.b &#x3D; this-&gt;b + p.b; return tmp; &#125; int a; int b;&#125;;int main()&#123; Person A; A.a &#x3D; 10; A.b &#x3D; 20; Person B; B.a &#x3D; 1; B.b &#x3D; 3; Person C; C &#x3D; A + B; cout &lt;&lt; C.a &lt;&lt; &quot; &quot; &lt;&lt; C.b &lt;&lt; endl;&#125; 运行结果： 全局函数实现加号重载： 1234567891011121314151617181920212223242526class Person&#123;public: int a; int b;&#125;;Person operator+(Person &amp;p1,Person &amp;p2)&#123; &#x2F;&#x2F;需要传入两个参数 Person tmp; tmp.a &#x3D; p1.a + p2.a; tmp.b &#x3D; p1.b + p2.b; return tmp;&#125;int main()&#123; Person A; A.a &#x3D; 10; A.b &#x3D; 20; Person B; B.a &#x3D; 1; B.b &#x3D; 3; Person C; C &#x3D; A + B; cout &lt;&lt; C.a &lt;&lt; &quot; &quot; &lt;&lt; C.b &lt;&lt; endl;&#125; 运行结果： 运算符重载也可以发生函数重载 12345678910111213141516171819202122232425262728293031323334353637class Person&#123;public: int a; int b;&#125;;Person operator+(Person &amp;p1,Person &amp;p2)&#123; Person tmp; tmp.a &#x3D; p1.a + p2.a; tmp.b &#x3D; p1.b + p2.b; return tmp;&#125;Person operator+(Person &amp;p1,int n)&#123; &#x2F;&#x2F;函数重载 Person tmp; tmp.a &#x3D; p1.a + n; tmp.b &#x3D; p1.b + n; return tmp;&#125;int main()&#123; Person A; A.a &#x3D; 10; A.b &#x3D; 20; Person B; B.a &#x3D; 1; B.b &#x3D; 3; Person C; C &#x3D; A + B; cout &lt;&lt; C.a &lt;&lt; &quot; &quot; &lt;&lt; C.b &lt;&lt; endl; Person D; D &#x3D; A + 10; cout &lt;&lt; D.a &lt;&lt; &quot; &quot; &lt;&lt; D.b &lt;&lt; endl;&#125; 运行结果: 左移运算符（“&lt;&lt;”）符重载可以输出自定义的数据类型。 123456789101112131415161718192021class Person&#123;public: int a; int b;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout , Person &amp;p)&#123; cout &lt;&lt; p.a &lt;&lt; &quot; &quot; &lt;&lt; p.b &lt;&lt; endl; return cout; &#x2F;&#x2F;返回cout 可以实现链式编程&#125;int main()&#123; Person A; A.a &#x3D; 10; A.b &#x3D; 20; cout &lt;&lt; A &lt;&lt; endl;&#125; 运行结果： 左移运算符重载无法用成员函数来实现因为要实现的是cout &lt;&lt; A &lt;&lt; endl;看例子吧~ 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public: int a; int b; ostream&amp; operator&lt;&lt;(ostream &amp;cout)&#123; cout &lt;&lt; this-&gt;a &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;b &lt;&lt; endl; return cout; &#125;&#125;;int main()&#123; Person A; A.a &#x3D; 10; A.b &#x3D; 20; A &lt;&lt; cout &lt;&lt; endl; &#x2F;&#x2F;如果用成员函数，最后实现了是这样的。。。(因为是A调用，所以A写在前)&#125; 运行结果： 递增运算符（“++”）重载123456789101112131415161718192021222324252627282930313233343536373839class Person&#123;public: int a; int b; Person&amp; operator++()&#123; &#x2F;&#x2F;前置递增返回的是引用，这样++(++A)也不会出错 a++; b++; return *this; &#125; &#x2F;&#x2F;后置递增返回的是值 Person operator++(int)&#123; &#x2F;&#x2F;int是占位参数，可以用来区分前置和后置，必须写int，其他类型不可以 Person tmp &#x3D; *this; a++; b++; return tmp; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;cout , Person &amp;p)&#123; cout &lt;&lt; p.a &lt;&lt; &quot; &quot; &lt;&lt; p.b &lt;&lt; endl; return cout;&#125;int main()&#123; Person A; A.a &#x3D; 10; A.b &#x3D; 20; cout &lt;&lt; &quot;原始A的值：&quot; &lt;&lt;A &lt;&lt; endl; ++A; cout &lt;&lt; &quot;A++后的值：&quot; &lt;&lt; A &lt;&lt; endl; A++; cout &lt;&lt; &quot;A++后的值：&quot; &lt;&lt; A &lt;&lt; endl;&#125; 运行结果： 赋值运算符（“=”）重载存在复制运算符的原因是堆区的数据重复释放，也就是浅拷贝的问题。详细解释： 在对象P1中new一个age变量，这个遍历被存储在堆区，需要程序员手动申请，手动释放，把P1赋给p2时，P2也指向这个堆区的地址空间，所以当使用析构函数对堆区数据进行释放时，P1释放了一次，P2又释放了一次，出现了堆区数据重复释放的情况，程序崩溃。 解决方案：利用深拷贝来解决浅拷贝的问题。因为出现程序崩溃的主要原因是，当p2 = p1时，p2直接指向了0x0011这块地址，使用赋值运算符重载，使p2 = p1时，p2开辟一个新的地址空间用来存储年龄18这个数据，这样在释放时，就不会重复释放了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person &#123;public: Person(int age) &#123; this-&gt;age &#x3D; new int(age); &#125; int *age; ~Person() &#123; if (age !&#x3D; NULL) &#123; delete age; age &#x3D; NULL; &#125; &#125; Person &amp;operator&#x3D;(Person &amp;p) &#123; &#x2F;&#x2F;返回类型是Person，可以链式赋值，p3 &#x3D; p2 &#x3D; p1 if (this-&gt;age !&#x3D; NULL) &#123; delete age; age &#x3D; NULL; &#125; age &#x3D; new int(*p.age); return *this; &#125;&#125;;int main() &#123; Person p1(10); cout &lt;&lt; *p1.age &lt;&lt; endl; &#x2F;&#x2F;p1.age是指针 Person p2(18); cout &lt;&lt; *p2.age &lt;&lt; endl; p2 &#x3D; p1; cout &lt;&lt; *p2.age &lt;&lt; endl; Person p3(20); cout &lt;&lt; *p3.age &lt;&lt; endl; p1 &#x3D; p2 &#x3D; p3; cout &lt;&lt; *p1.age &lt;&lt; &quot; &quot; &lt;&lt; *p2.age &lt;&lt; &quot; &quot; &lt;&lt; *p3.age &lt;&lt; endl;&#125; 运行结果： 关系运算符重载1234567891011121314151617181920212223242526272829303132333435public: Person(string name, int age,int sex) &#123; this-&gt;name &#x3D; name; this-&gt;age &#x3D; age; this-&gt;sex &#x3D; sex; &#125; string name; int age; int sex; bool operator&#x3D;&#x3D;(Person &amp;p)&#123; return this-&gt;name &#x3D;&#x3D; p.name &amp;&amp; this-&gt;age &#x3D;&#x3D; p.age &amp;&amp; this-&gt;sex &#x3D;&#x3D; p.sex; &#125; bool operator!&#x3D;(Person &amp;p)&#123; return !(this-&gt;name &#x3D;&#x3D; p.name &amp;&amp; this-&gt;age &#x3D;&#x3D; p.age &amp;&amp; this-&gt;sex &#x3D;&#x3D; p.sex); &#125;&#125;;int main() &#123; Person p1(&quot;Tom&quot;,23,1); Person p2(&quot;Tom&quot;,23,1); Person p3(&quot;Amy&quot;,23,2); cout &lt;&lt; (p1 &#x3D;&#x3D; p2 ? &quot;相等&quot; : &quot;不相等&quot;)&lt;&lt; endl; cout &lt;&lt; (p2 &#x3D;&#x3D; p3 ? &quot;相等&quot; : &quot;不相等&quot;)&lt;&lt; endl; cout &lt;&lt; (p1 !&#x3D; p2 ? &quot;不相等&quot; : &quot;相等&quot;)&lt;&lt; endl; cout &lt;&lt; (p2 !&#x3D; p3 ? &quot;不相等&quot; : &quot;相等&quot;)&lt;&lt; endl;&#125; 运行结果： 函数调用运算符重载1234567891011121314151617181920class Person &#123;public: void operator()(int b) &#123; cout &lt;&lt; b &lt;&lt; endl; &#125;&#125;;int main() &#123; Person p1; p1.operator()(6); &#x2F;&#x2F; 匿名函数对象 Person()(9);&#125; 运行结果： 菜鸟教程的C++ 重载运算符和重载函数 补充：","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Python实现排序及时间空间复杂度分析","slug":"Python实现排序及时间空间复杂度分析","date":"2020-03-11T13:54:19.000Z","updated":"2020-05-13T01:59:35.776Z","comments":true,"path":"2020/03/11/Python实现排序及时间空间复杂度分析/","link":"","permalink":"http://yoursite.com/2020/03/11/Python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"原文链接：https://www.jianshu.com/p/e398e4c3bb05 一、冒泡排序（Bubble Sort）原理： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。（从头到尾，从尾到头都可以） 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。","text":"原文链接：https://www.jianshu.com/p/e398e4c3bb05 一、冒泡排序（Bubble Sort）原理： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。（从头到尾，从尾到头都可以） 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动画： 图片说明第一次排序：图片说明所有排序： Python实现： 123456def BubbleSort(matrix): for i in range(len(matrix) - 1): for j in range(len(matrix)-i-1):#要用到j+1，防止溢出，减掉1 if matrix[j] &gt; matrix[j + 1]: matrix[j], matrix[j + 1] &#x3D; matrix[j + 1], matrix[j] return matrixB 从左到右找到依次找到较大的元素，如果左边的元素比右边的元素大，交换这两个元素。一共循环了len（matrix）-1次。 优化:如果一个已经排好的数组，用这个算法还是要比较很多次。所以增加一个flag，赋值为True，在一次循环中，如果没有两个元素进行交换，说明数组是已经排好序的，在当前循环结束时，flag的值没有发生改变依旧为True，可直接break出循环。 123456789def BubbleSort(matrix): flag &#x3D; True for i in range(len(matrix) - 1): for j in range(len(matrix) - i - 1): if matrix[j] &gt; matrix[j + 1]: matrix[j], matrix[j + 1] &#x3D; matrix[j + 1], matrix[j] flag &#x3D; False if (flag): break return matrix 时间复杂度分析：外层的for时间复杂度为O（n）里层的时间复杂度分析如下：因为里层的起点是0，结束是len（matrix）-i-1，（以下用n代替len（matrix））当i == 0 时，里层循环是n-1次，i == 1时，循环为n-1次，当i == n-1时，需要0次。把i为（0，n-1）时所有的循环次数加起来就是从0加到n-1，值为首项加尾项乘以项数除以二，即（0+n-1）n/2，这个的时间复杂度我O（n）。所有里层的循环时间复杂度为O（n）。所以时间复杂度为O（n^2） 最差情况是需要交换n^2次，最好情况是不需要交换。 空间复杂度：不需要额外的空间。所以O（1） 稳定性：冒泡排序是一个稳定的排序方式，比如matrix = [25, 25, 3, 9, 23, 44, 29]时，出现了两个25，在冒泡排序结束后，从左边数的第一个25，在排序结束时，依旧是从左数的第一个25，它不会出现在第二个25的右面。（因为在元素相等的时候没有进行交换） 二、选择排序（Selction Sort）原理：第一次循环找出最大值（最小值），记录其下标，把他与最末尾（首）的元素交换，第二次找到第二大的，与倒数第二末尾的元素进行交换。第一次循环的范围是（0，数组长度-1），第二次是（0，数组长度-2）动画：图片说明：Python实现： 12345678910def SelectionSort(matrix): n &#x3D; len(matrix) for i in range(n): index &#x3D; 0 for j in range(n - i): if matrix[j] &gt; matrix[index]: index &#x3D; j matrix[n - i - 1], matrix[index] &#x3D; matrix[index], matrix[n - i - 1] return matrix 时间复杂度分析：两次for循环：O（n^2），进行了O（n）次交换。 空间复杂度：不需要额外的空间。所以O（1） 稳定性：不稳定。 三、插入排序（Insert Sort）原理：相当于打牌时候摸牌，如数组[25, 5, 3, 9, 23, 44, 29]，第一张摸到的牌是25，第二张摸到了5，与25比较大小，放在25前面，依次摸完所有的牌，也就排序结束了。动画：图片说明：Python实现： 123456789101112def InsertSort(matrix): n &#x3D; len(matrix) for i in range(1, n): cur &#x3D; i pre &#x3D; cur - 1 while pre &gt;&#x3D; 0 and matrix[cur] &lt; matrix[pre]: if matrix[cur] &lt; matrix[pre]: matrix[pre], matrix[cur] &#x3D; matrix[cur], matrix[pre] cur &#x3D; pre pre &#x3D; cur - 1 return matrix 定义一个cur来存储当前的下标，因为pre是cir-1，所以循环从1开始。 12345678910def InsertSort(matrix): n &#x3D; len(matrix) for i in range(1, n): cur &#x3D; i while cur - 1 &gt;&#x3D; 0 and matrix[cur] &lt; matrix[cur - 1]: if matrix[cur] &lt; matrix[cur - 1]: matrix[cur - 1], matrix[cur] &#x3D; matrix[cur], matrix[cur - 1] cur -&#x3D; 1 return matrix 把pre用cur-1代替了。 也可以： 1234567891011def InsertSort(matrix): for i in range(1, len(matrix)): tmp &#x3D; i while i &gt; 0: if matrix[i] &lt; matrix[i - 1]: matrix[i], matrix[i - 1] &#x3D; matrix[i - 1], matrix[i] i -&#x3D; 1 else: break return matrix 时间复杂度分析：两个嵌套的循环，时间复杂度是O(n^2)。虽然时间复杂度也是O(n^2)，但是第二层循环不需要与所有元素进行比较，所以在性能上优于冒泡排序和选择排序。空间复杂度：没有额外的存储空间，是原地排序算法O（1）。稳定性：稳定 四、希尔排序（Shell Sort）原理：实际上是插入排序的扩展，把数组分成几组，比如数组[25, 5, 3, 9, 23, 44, 29]，数组长度n为7，取gap = n/2，把数组的[i]和[i+gap]作为一组，比较[i]和[i+gap]的大小，如果[i]&gt;[i+gap]，交换[i]和[i+gap]，如果[i]&lt;[i+gap]，则继续比较[i+1]和[i+gap+1]，把数组里的所有元素都比较完之后，再把gap的值减小，可以减1，也可以把gap/2，继续比较，直至最后一次把数组中的所有元素作为一个整体排序。动画：图片说明：Python实现： 1234567891011121314def ShellSort(matrix): n &#x3D; len(matrix) gap &#x3D; n &#x2F;&#x2F; 2 while gap &gt; 0: for i in range(gap, n): for tmp in range(i, gap - 1, -gap): if matrix[tmp] &lt; matrix[tmp - gap]: matrix[tmp], matrix[tmp - gap] &#x3D; matrix[tmp - gap], matrix[tmp] if gap &#x3D;&#x3D; 2: gap &#x3D; 1 else: gap &#x2F;&#x2F;&#x3D; 2 return matrix 五、计数排序（Count Sort）使用范围：数组长度有限，较小。出现的重复数字比较多，并且这些数值较为集中。原理：抽屉原理：遍历数组，把相同的值都放到同一个抽屉中，遍历结束后，按照值从小到大的顺序依次取出，即排列完成。动画： 图片说明： Python实现： 1234567891011121314151617181920def CountSort(matrix): max &#x3D; matrix[0] min &#x3D; matrix[0] for i in matrix: #找到list中的最大元素和最小元素 if i &gt; max: max &#x3D; i if i &lt; min: min &#x3D; i tmp &#x3D; [0] * (max - min + 1) # 定义一个新的数组，长度为最大值减最小值加一 for i in range(len(matrix)): #把原来数组中每个数字出现了多少次存在新数组中 tmp[matrix[i] - min] +&#x3D; 1 index &#x3D; 0 for j in range(len(tmp)): # while tmp[j] &gt; 0: matrix[index] &#x3D; min + j index +&#x3D; 1 tmp[j] -&#x3D; 1 return matrix 时间复杂度分析：第一个循环：O（n）第二个循环：O（n）第三个循环：O（n），虽然有两个for但是实际上是从头到尾把元素都拿出来，只走了一遍所以时间复杂度还是O（n）所以时间复杂度为O（n）稳定性：不稳定 六、归并排序（Merge Sort）原理：把数组从中间分成前后两个数组，再把前后两个数组每个数组再分，分到最小，然后对前后两部分分别排序，再将排好序的两部分合并在一起。 图片说明：Python实现： 1234567891011121314151617181920212223242526272829def MergeSort(matrix): matrix &#x3D; devide(matrix) return matrixdef devide(matrix): if len(matrix) &lt;&#x3D; 1: return matrix m &#x3D; len(matrix) &#x2F;&#x2F; 2 a &#x3D; devide(matrix[:m]) b &#x3D; devide(matrix[m:]) return merge(a, b)def merge(num1,num2): num &#x3D; [] while len(num1) &gt; 0 and len(num2) &gt; 0: if num1[0] &gt; num2[0]: num.append(num2[0]) num2.remove(num2[0]) else: num.append(num1[0]) num1.remove(num1[0]) if len(num1) &#x3D;&#x3D; 0: num +&#x3D; num2 else: num +&#x3D; num1 return num 时间复杂度：时间复杂度是 O(nlogn)，要优于 O(n^2)。空间复杂度：空间复杂度是 O(n)。稳定性：稳定 七、快速排序（Quick Sort）原理：数组的一个元素赋给下标赋给first，末尾下标赋给last，把数组从左到右第一个元素的值赋给pivot，从数组末尾往前找到第一个比pivot值小的数，赋给matrix[first]，再从first往后找到第一个比pivot大的值，当first与last相遇时，把pivot的值赋给matrix[first]或matrix[last]，然后递归。 Python实现： 123456789101112131415161718192021def QuickSort(matrix, i, j): if i &gt;&#x3D; j or i &lt; 0 or j &gt; len(matrix)-1: return else: first &#x3D; i last &#x3D; j pivot &#x3D; matrix[i] while first &lt; last: while first &lt; last and matrix[last] &gt; pivot: last -&#x3D; 1 matrix[i] &#x3D; matrix[last] while first &lt; last and matrix[first] &lt; pivot: first +&#x3D; 1 matrix[last] &#x3D; matrix[first] matrix[first]&#x3D; pivot QuickSort(matrix, i, first - 1) QuickSort(matrix, first + 1, j) return matrix 快排参考链接：https://blog.csdn.net/u010005281/article/details/80084994 文章参考：硬核！C语言八大排序算法，附动图和详细代码解释！这或许是东半球分析十大排序算法最好的一篇文章十大经典排序算法（动图演示）数据结构与算法系列（五）基于选择的排序算法","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"Others","slug":"Others","permalink":"http://yoursite.com/categories/Others/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Anki","slug":"Anki","permalink":"http://yoursite.com/tags/Anki/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]}